<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>香克斯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.shanks.pro/"/>
  <updated>2019-12-29T10:15:21.438Z</updated>
  <id>www.shanks.pro/</id>
  
  <author>
    <name>shanks</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS进程间通信</title>
    <link href="www.shanks.pro/2019/12/29/ios-communicate-between-app-process/"/>
    <id>www.shanks.pro/2019/12/29/ios-communicate-between-app-process/</id>
    <published>2019-12-29T04:33:37.000Z</published>
    <updated>2019-12-29T10:15:21.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主旨"><a href="#主旨" class="headerlink" title="主旨"></a>主旨</h2><p>本章主要介绍Google在开源项目<a href="https://github.com/google/EarlGrey" target="_blank" rel="noopener">EarlGrey</a>中用到的进程间通信的方式<a href="https://github.com/google/eDistantObject" target="_blank" rel="noopener">eDistantObject</a>的实现原理。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做自动化探索测试的过程中，发现Apple提供的UI测试（黑盒），对App元素的操作有点局限，获取的信息也不能完全满足要求，所以想到是否可以通过在被测试App内部获取和操作元素（白盒），然后在另一个App（测试App）中进行全流程控制，达到兼具白盒和黑盒的效果。</p><blockquote><p>既然能在测试App内部操作，为什么还一定需要一个测试App来控制？因为在App内部没法完成所以自动化测试的公共，比如系统Alert的处理。这个不是本章重点，不赘述。</p></blockquote><p>那么问题来了，抛开Apple的UI测试，我们怎么才能在测试App中和被测试App进行通信，这里就需要有一种通信方式来在完成App间的数据沟通。下面我们介绍下eDistantObject的大致原理和实现。<br><a id="more"></a></p><h2 id="基础知识提要"><a href="#基础知识提要" class="headerlink" title="基础知识提要"></a>基础知识提要</h2><h3 id="什么是socket"><a href="#什么是socket" class="headerlink" title="什么是socket"></a>什么是socket</h3><p>引用Unix网络编程中的介绍(1.7章)</p><blockquote><p>The sockets programming interfaces described in this book are interfaces from the upper three<br>layers (the “application”) into the transport layer.<br>大致意思是，socket是一套实现应用册到传输层的接口实现。配合下面这张图会更加清晰一些。</p></blockquote><p><img src="/assets/socket-osi.png" alt="Layers in OSI model and Internet protocol suite."></p><p>至于为什么需要socket，文中也有解释，只要是两点原因。</p><ol><li>上三层协议主要处理应用层信息（FTP/HTTP）而不关注通信细节，而下四层主要处理通信细节而不关注应用层信息。</li><li>上三层作用在用户进程，而下四层通常作为OS内核的一部分提供。</li></ol><p>所以在第四和第五层之间构建这样一个沟通上下的接口就可以理解了。</p><h3 id="socket的工作方式"><a href="#socket的工作方式" class="headerlink" title="socket的工作方式"></a>socket的工作方式</h3><p>Unix网络编程中有一个实现基于TCP的例子(4.1章)，我们可以用这个来解释。</p><p><img src="/assets/socket-tcp.png" alt="Socket functions for elementary TCP client/server."></p><ol><li>server端先创建socket连接-&gt;绑定本地地址-&gt;监听端口-&gt;接受请求。</li><li>client端建立socket连接-&gt;向server端请求建立连接。</li><li>连接建立之后，client向server请求数据，server读取数据之后，给client写数据。</li><li>client收到数据之后读取出来。</li><li>所有任务结束之后断开socket连接。</li></ol><p>有关于图中每个方法的具体细节，可以直接通过man了解到.</p><h2 id="eDistantObject实现"><a href="#eDistantObject实现" class="headerlink" title="eDistantObject实现"></a>eDistantObject实现</h2><p>eDistantObject的README中提供的范例是先在Host端建立一个service，然后在client端根据Host端的端口去调用Host端的方法。这和我们上面的socket通信中的client/server模式很像。我们就先从Host建立service为切入点看下它的代码。</p><h3 id="EDOHostService"><a href="#EDOHostService" class="headerlink" title="EDOHostService"></a>EDOHostService</h3><table><thead><tr><th style="text-align:left">调用顺序</th></tr></thead><tbody><tr><td style="text-align:left">[EDOHostService serviceWithPort:rootObject:queue:]</td></tr><tr><td style="text-align:left">[EDOHostService initWithPort:rootObject:serviceName:queue:isToDevice:]</td></tr><tr><td style="text-align:left">[EDOHostService edo_createListenSocket:]</td></tr></tbody></table><p>从入口初始化一路向下，省略掉其中一些变量初始化的工作，我们把关注点放到edo_createListenSocket上，从命名上也能看出，edo_createListenSocket其实创建了一个socket连接，监听请求来的数据。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (EDOSocket *)edo_createListenSocket:(<span class="built_in">UInt16</span>)port &#123;</span><br><span class="line">  __<span class="keyword">weak</span> EDOHostService *weakSelf = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">return</span> [EDOSocket listenWithTCPPort:port</span><br><span class="line">                                queue:<span class="literal">nil</span></span><br><span class="line">                       connectedBlock:^(EDOSocket *socket, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                         EDOHostService *strongSelf = weakSelf;</span><br><span class="line">                         <span class="keyword">if</span> (!strongSelf) &#123;</span><br><span class="line">                           [socket invalidate];</span><br><span class="line">                           <span class="keyword">return</span>;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">id</span>&lt;EDOChannel&gt; clientChannel = [EDOSocketChannel channelWithSocket:socket];</span><br><span class="line">                         [strongSelf startReceivingRequestsForChannel:clientChannel];</span><br><span class="line">                       &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edo_createListenSocket的代码里，我们可以看到两部分内容，一部分是EDOSocket创建一个socket监听指定端口，另一部是在回调里处理数据。具体细节能在EDOSocket和startReceivingRequestsForChannel中找到。</p><h3 id="EDOSocket"><a href="#EDOSocket" class="headerlink" title="EDOSocket"></a>EDOSocket</h3><table><thead><tr><th style="text-align:left">调用顺序</th></tr></thead><tbody><tr><td style="text-align:left">[EDOSocket listenWithTCPPort:queue:connectedBlock:]</td></tr><tr><td style="text-align:left">[EDOListenSocket listenSocketWithSocket:connectedBlock:]</td></tr></tbody></table><p>EDOSocket的原理基本上都在上面两个方法中了，我们一个一个看。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">+ (EDOSocket *)listenWithTCPPort:(<span class="built_in">UInt16</span>)port</span><br><span class="line">                           queue:(<span class="built_in">dispatch_queue_t</span>)queue</span><br><span class="line">                  connectedBlock:(EDOSocketConnectedBlock)block &#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="comment">// 1 - socket()</span></span><br><span class="line">  dispatch_fd_t socketFD = edo_CreateSocket(&amp;socketErr);</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="comment">// 2 - bind</span></span><br><span class="line">  <span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">  memset(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">  addr.sin_port = htons(port);</span><br><span class="line">  addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);</span><br><span class="line">  <span class="keyword">if</span> (bind(socketFD, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) != <span class="number">0</span>) &#123;</span><br><span class="line">    close(socketFD);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// listen</span></span><br><span class="line">  <span class="keyword">return</span> [EDOListenSocket listenSocketWithSocket:socketFD</span><br><span class="line">                                  connectedBlock:^(EDOSocket *socket, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                                    <span class="comment">// dispatch the block to the user's queue</span></span><br><span class="line">                                    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                                      block(socket, <span class="literal">nil</span>);</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                  &#125;];</span><br><span class="line">&#125;</span><br><span class="line">+ (EDOListenSocket *)listenSocketWithSocket:(dispatch_fd_t)socketFD</span><br><span class="line">                             connectedBlock:(EDOSocketConnectedBlock)block &#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="comment">// 3 - listen</span></span><br><span class="line">  <span class="keyword">if</span> (listen(socketFD, SOMAXCONN) != <span class="number">0</span>) &#123;</span><br><span class="line">    close(socketFD);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> eventQueue =</span><br><span class="line">      dispatch_queue_create(gListenSocketQueueLabel, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">  dispatch_source_t source =</span><br><span class="line">      dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, (uintptr_t)socketFD, <span class="number">0</span>, eventQueue);</span><br><span class="line"></span><br><span class="line">  EDOListenSocket *listenSocket = [EDOListenSocket socketWithSocket:socketFD source:source];</span><br><span class="line">  __<span class="keyword">weak</span> EDOListenSocket *weakSelf = listenSocket;</span><br><span class="line">  dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">    EDOListenSocket *strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nconns = dispatch_source_get_data(source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nconns &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 4 - accept</span></span><br><span class="line">      EDOSocket *socket = [strongSelf accept:socketFD];</span><br><span class="line">      <span class="comment">// 5 - 处理数据</span></span><br><span class="line">      <span class="keyword">if</span> (socket) &#123;</span><br><span class="line">        block(socket, <span class="literal">nil</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      --nconns;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_source_set_cancel_handler(source, ^&#123;</span><br><span class="line">    <span class="comment">// Release the socket and reset it to -1.</span></span><br><span class="line">    EDOSocket *strongSelf = weakSelf;</span><br><span class="line">    [strongSelf releaseSocket];</span><br><span class="line">    close(socketFD);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_resume(source);</span><br><span class="line">  <span class="keyword">return</span> listenSocket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面大致做了3件事</p><ol><li>调用了edo_CreateSocket创建了socket，这是封装后的方法，内部其实直接调用原始socket的socket(AF_INET, SOCK_STREAM, 0)。</li><li>紧接着调用通过bind绑定本地地址。</li><li>调用listen监听连接。</li><li>调用accept接受连接</li><li>通过回调处理数据。</li></ol><p>至此，初始化HostService的任务基本结束，从代码上看，和标准的socket初始化没什么区别。初始化完之后就剩下数据的接受和处理了。</p><blockquote><p>Unix中I/O相关的资源都使用文件描述符操作，所以这里socket创建之后返回的也是文件描述符。Everything is a file！</p></blockquote><h3 id="Host接受数据"><a href="#Host接受数据" class="headerlink" title="Host接受数据"></a>Host接受数据</h3><p>startReceivingRequestsForChannel之前，创建了一个channel来作为发送和接收数据的通道。<br>| 调用顺序 |<br>| :—– |<br>| [EDOSocketChannel channelWithSocket:] |<br>| [EDOSocketChannel initWithSocket:] |<br>| [EDOSocketChannel initWithDispatchIO:] |<br>| [EDOSocket releaseAsDispatchIO] |</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> dispatch_io_t)releaseAsDispatchIO &#123;</span><br><span class="line">  dispatch_fd_t socket = [<span class="keyword">self</span> releaseSocket];</span><br><span class="line">  <span class="comment">// 省略=</span></span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.google.edo.SocketIO"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">  dispatch_io_t channel = dispatch_io_create(DISPATCH_IO_STREAM, socket, queue, ^(<span class="keyword">int</span> error) &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，EDOSocketChannel的本质是创建了一个Dispatch I/O通道来读取client通过socket传送过来的数据。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)receiveDataWithHandler:(EDOChannelReceiveHandler)handler &#123;</span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> handlerQueue = <span class="keyword">self</span>.handlerQueue;</span><br><span class="line">  dispatch_io_t channel = <span class="keyword">self</span>.channel;</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">  dispatch_io_handler_t dataHandler = ^(<span class="keyword">bool</span> done, dispatch_data_t data, <span class="keyword">int</span> error) &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    <span class="built_in">NSMutableData</span> *receivedData =</span><br><span class="line">        [<span class="built_in">NSMutableData</span> dataWithCapacity:dispatch_data_get_size(dataReceived)];</span><br><span class="line">    dispatch_data_apply(dataReceived, ^<span class="keyword">bool</span>(dispatch_data_t region, size_t offset,</span><br><span class="line">                                            <span class="keyword">const</span> <span class="keyword">void</span> *buffer, size_t size) &#123;</span><br><span class="line">      [receivedData appendBytes:buffer length:size];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">      <span class="built_in">dispatch_async</span>(handlerQueue, ^&#123;</span><br><span class="line">        handler(<span class="keyword">self</span>, receivedData, <span class="literal">nil</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dispatch_io_handler_t frameHandler = ^(<span class="keyword">bool</span> done, dispatch_data_t data, <span class="keyword">int</span> error) &#123;</span><br><span class="line">    size_t payloadSize = EDOGetPayloadSizeFromFrameData(data);</span><br><span class="line">    <span class="comment">//省略许多</span></span><br><span class="line">    dispatch_io_read(channel, <span class="number">0</span>, payloadSize, handlerQueue, dataHandler);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dispatch_io_read(channel, <span class="number">0</span>, EDOGetPayloadHeaderSize(), handlerQueue, frameHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EDOSocketChannel内部再从Dispatch I/O中不断的读取拼接数据并将数据通过handler发送出去。<br>当通道数据发送到外面之后，就需要对收到的数据进行具体的处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startReceivingRequestsForChannel:(<span class="keyword">id</span>&lt;EDOChannel&gt;)channel &#123;</span><br><span class="line">  <span class="comment">//省略无关代码</span></span><br><span class="line">  EDOChannelReceiveHandler receiveHandler =</span><br><span class="line">      ^(<span class="keyword">id</span>&lt;EDOChannel&gt; targetChannel, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        EDOChannelReceiveHandler strongHandlerBlock = weakHandlerBlock;</span><br><span class="line">        EDOServiceRequest *request = [<span class="built_in">NSKeyedUnarchiver</span> edo_unarchiveObjectWithData:data];</span><br><span class="line">        <span class="built_in">NSString</span> *requestClassName = <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]);</span><br><span class="line">        <span class="comment">//获取匹配的handler</span></span><br><span class="line">        EDORequestHandler handler = EDOHostService.handlers[requestClassName];</span><br><span class="line">        __block EDOServiceResponse *response = <span class="literal">nil</span>;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">          __<span class="keyword">weak</span> EDOServiceRequest *weakRequest = request;</span><br><span class="line">          <span class="keyword">void</span> (^requestHandler)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            uint64_t currentTime = mach_absolute_time();</span><br><span class="line">            response = handler(weakRequest, weakSelf);</span><br><span class="line">            response.duration = EDOGetMillisecondsSinceMachTime(currentTime);</span><br><span class="line">          &#125;;</span><br><span class="line">          [strongSelf.executor handleBlock:requestHandler error:&amp;error];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSData</span> *responseData = [<span class="built_in">NSKeyedArchiver</span> edo_archivedDataWithObject:response];</span><br><span class="line">        <span class="comment">// 发送respone</span></span><br><span class="line">        [targetChannel sendData:responseData withCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">        <span class="comment">// 循环直到全部处理完</span></span><br><span class="line">        <span class="keyword">if</span> ([strongSelf edo_shouldReceiveData:channel]) &#123;</span><br><span class="line">          [targetChannel receiveDataWithHandler:strongHandlerBlock];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  receiveHandler = [receiveHandler <span class="keyword">copy</span>];</span><br><span class="line">  [channel receiveDataWithHandler:receiveHandler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要解析出request，然后根据request的类型，去除对应的handeler，执行完之后如果将response（包装成EDOObject）发送会client端。其中handler主要有以下几个:</p><ul><li>EDOClassRequest</li><li>EDOInvocationRequest</li><li>EDOMethodSignatureRequest</li><li>EDOObjectAliveRequest</li><li>EDOObjectRequest</li><li>EDOObjectReleaseRequest</li></ul><p>至此Host端（我们熟悉的socket中的Server端）以及全部结束。根据socket的流程，我们不难猜想出Client端的工作流程。</p><h3 id="EDOClientService"><a href="#EDOClientService" class="headerlink" title="EDOClientService"></a>EDOClientService</h3><table><thead><tr><th style="text-align:left">调用顺序</th></tr></thead><tbody><tr><td style="text-align:left">[EDOClientService responseObjectWithRequest:onPort:]</td></tr><tr><td style="text-align:left">[EDOClientService sendSynchronousRequest:onPort:]</td></tr><tr><td style="text-align:left">[EDOClientService sendSynchronousRequest:onPort:withExecutor]</td></tr><tr><td style="text-align:left">[EDOChannelPool channelWithPort:error:]</td></tr><tr><td style="text-align:left">[EDOChannelPool edo_createChannelWithPort:error:]</td></tr><tr><td style="text-align:left">[EDOSocket socketWithTCPPort:queue:error:]</td></tr><tr><td style="text-align:left">[EDOSocket connectWithTCPPort:queue:connectedBlock:]</td></tr></tbody></table><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)connectWithTCPPort:(<span class="built_in">UInt16</span>)port</span><br><span class="line">                     queue:(<span class="built_in">dispatch_queue_t</span>)queue</span><br><span class="line">            connectedBlock:(EDOSocketConnectedBlock)block &#123;</span><br><span class="line">  <span class="comment">// 1 - socket</span></span><br><span class="line">  dispatch_fd_t socketFD = edo_CreateSocket(&amp;socketErr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">  memset(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = htons(port);</span><br><span class="line">  addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);</span><br><span class="line">  <span class="comment">// 2 - connect</span></span><br><span class="line">  <span class="keyword">int</span> ret = connect(socketFD, (<span class="keyword">struct</span> sockaddr <span class="keyword">const</span> *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">  socketErr = errno;</span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; socketErr != EINPROGRESS) &#123;</span><br><span class="line">    edo_RunHandlerWithErrorInQueueWithBlock(socketErr, queue, block);</span><br><span class="line">    close(socketFD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显可以看到，这里也是遵循标准socket的流程，做了两件事。</p><ol><li>调用socket()创建socket。</li><li>调用connect和Host建立连接。</li></ol><p>现在两边连接已经建立，下面就到了Client调用Host的时候。</p><h3 id="EDOObject"><a href="#EDOObject" class="headerlink" title="EDOObject"></a>EDOObject</h3><p>官方README是这样说的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="comment">// The object, fetched remotely from the host is seen by the client to be the same as a local</span></span><br><span class="line">  <span class="comment">// object.</span></span><br><span class="line">  FooClass *rootObject = [EDOClientService rootObjectWithPort:portNumber];</span><br><span class="line">  [rootObject method1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的FooClass就是一个在Host中实现的普通类，之所以在Client进程中能够直接调用，是因为EDOClientService返回的是EDOObject，method1的实现并不是在Client进程，所以看起来直接调用method1能成功，是因为真正的调用会被EDOObject发送到Host端，然后将数据返回，这中间就用到OC的消息转发+socket通信。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EDOObject+Invocation</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">  <span class="comment">// TODO(haowoo): Cache the signature.</span></span><br><span class="line">  EDOServiceRequest *request = [EDOMethodSignatureRequest requestWithObject:<span class="keyword">self</span>.remoteAddress</span><br><span class="line">                                                                       port:<span class="keyword">self</span>.servicePort</span><br><span class="line">                                                                   selector:selector];</span><br><span class="line">  EDOMethodSignatureResponse *response = (EDOMethodSignatureResponse *)[EDOClientService</span><br><span class="line">      sendSynchronousRequest:request</span><br><span class="line">                      onPort:<span class="keyword">self</span>.servicePort.hostPort];</span><br><span class="line">  <span class="built_in">NSString</span> *signature = response.signature;</span><br><span class="line">  <span class="keyword">return</span> signature ? [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature.UTF8String] : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Forwards the invocation to the remote. */</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">  [<span class="keyword">self</span> edo_forwardInvocation:invocation selector:invocation.selector returnByValue:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)edo_forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">                     selector:(SEL)selector</span><br><span class="line">                returnByValue:(<span class="built_in">BOOL</span>)returnByValue &#123;</span><br><span class="line">  EDOInvocationRequest *request = [EDOInvocationRequest requestWithInvocation:invocation</span><br><span class="line">                                                                       target:<span class="keyword">self</span></span><br><span class="line">                                                                     selector:selector</span><br><span class="line">                                                                returnByValue:returnByValue</span><br><span class="line">                                                                      service:service];</span><br><span class="line">  EDOExecutor *executor = [EDOHostService serviceForCurrentExecutingQueue].executor;</span><br><span class="line">  EDOInvocationResponse *response =</span><br><span class="line">      (EDOInvocationResponse *)[EDOClientService sendSynchronousRequest:request</span><br><span class="line">                                                                 onPort:<span class="keyword">self</span>.servicePort.hostPort</span><br><span class="line">                                                           withExecutor:executor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EDOObject+Invocation文件中，覆写了methodSignatureForSelector和forwardInvocation，因为method1方法在EDOObject中肯定不存在，所以会直接走转发流程，所以消息会被封装，通过EDOChannel发送到Host进程，从Host进程拿返回数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上代码分析，可以总结出，eDistantObject使用了标准的socket流程在Host进程和Client进程建立了socket连接，然后将Client中的方法调用全部以消息转发的形式发送到Host进程，由Host进程处理完毕再返回被Client进程，达到我们表面上看起来的跨进程调用方法。<br>eDistantObject在README中也给出了一张原理图，也很好的诠释了这一过程。</p><p><img src="/assets/edistantobject-client-host.png" alt="Client-Host"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/google/eDistantObject/blob/master/docs/detail.md" target="_blank" rel="noopener">eDistantObject</a></li><li><a href="https://scoecomp.files.wordpress.com/2014/02/2003-unix-network-programming-vol-1-3rd-ed.pdf" target="_blank" rel="noopener">UNIX Network Programming</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主旨&quot;&gt;&lt;a href=&quot;#主旨&quot; class=&quot;headerlink&quot; title=&quot;主旨&quot;&gt;&lt;/a&gt;主旨&lt;/h2&gt;&lt;p&gt;本章主要介绍Google在开源项目&lt;a href=&quot;https://github.com/google/EarlGrey&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EarlGrey&lt;/a&gt;中用到的进程间通信的方式&lt;a href=&quot;https://github.com/google/eDistantObject&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;eDistantObject&lt;/a&gt;的实现原理。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在做自动化探索测试的过程中，发现Apple提供的UI测试（黑盒），对App元素的操作有点局限，获取的信息也不能完全满足要求，所以想到是否可以通过在被测试App内部获取和操作元素（白盒），然后在另一个App（测试App）中进行全流程控制，达到兼具白盒和黑盒的效果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;既然能在测试App内部操作，为什么还一定需要一个测试App来控制？因为在App内部没法完成所以自动化测试的公共，比如系统Alert的处理。这个不是本章重点，不赘述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么问题来了，抛开Apple的UI测试，我们怎么才能在测试App中和被测试App进行通信，这里就需要有一种通信方式来在完成App间的数据沟通。下面我们介绍下eDistantObject的大致原理和实现。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="进程间通信" scheme="www.shanks.pro/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
      <category term="eDistantObject" scheme="www.shanks.pro/tags/eDistantObject/"/>
    
      <category term="EarlGrey" scheme="www.shanks.pro/tags/EarlGrey/"/>
    
      <category term="socket" scheme="www.shanks.pro/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>iOS增量代码覆盖率</title>
    <link href="www.shanks.pro/2019/12/07/increment-code-coverage/"/>
    <id>www.shanks.pro/2019/12/07/increment-code-coverage/</id>
    <published>2019-12-07T02:05:35.000Z</published>
    <updated>2019-12-27T09:48:22.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是增量覆盖率"><a href="#什么是增量覆盖率" class="headerlink" title="什么是增量覆盖率"></a>什么是增量覆盖率</h2><p>增量覆盖率，顾名思义，指的是每次代码改动的增量部分，开发自测的覆盖程度。</p><h2 id="为什么需要增量覆盖率"><a href="#为什么需要增量覆盖率" class="headerlink" title="为什么需要增量覆盖率"></a>为什么需要增量覆盖率</h2><p>大型项目为了持续保证代码和App的质量，需要对新引入代码进行审查，而在代码被合并进去之前（比如在code review阶段），增量覆盖率无疑是衡量开发对代码的自测重复程度的一个很好的指标。</p><blockquote><p>代码覆盖率不是万能的，只能通过这个手段解决一部分明显通过自测就可以发现的问题。</p></blockquote><blockquote><p>增量代码覆盖率更偏向于开发使用，保证开发自测的充分程度。</p></blockquote><a id="more"></a><h2 id="怎么实现增量代码覆盖率"><a href="#怎么实现增量代码覆盖率" class="headerlink" title="怎么实现增量代码覆盖率"></a>怎么实现增量代码覆盖率</h2><p><img src="/assets/increment-code-coverage-plan.png" alt=""></p><p>上图展示了基本的思路，主要分3步。</p><ol><li>采集全量覆盖率</li><li>采集代码diff</li><li>根据代码diff和全量覆盖率过滤出增量覆盖率</li></ol><h3 id="采集全量覆盖率"><a href="#采集全量覆盖率" class="headerlink" title="采集全量覆盖率"></a>采集全量覆盖率</h3><p>全量覆盖率的采集，需要以下几步。</p><ul><li>配置工程，使得能在运行时插桩产生覆盖率数据。</li></ul><p>这里我们采用ruby脚本，每次需要的时候自动将配置加到工程里。需要注意的是，如果需要统计的不是主project而是依赖的子project，这个配置需要加到子的project中，因为这样子的project在编译时才能进行IR插桩。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">add_coverage_build_setting</span><span class="params">()</span></span></span><br><span class="line">    project = Xcodeproj::Project.open(project_path)</span><br><span class="line">    main_target = project.native_targets.first</span><br><span class="line">    main_target.build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">      <span class="keyword">if</span> config.name == <span class="string">"Debug"</span></span><br><span class="line">        config.build_settings[<span class="string">'GCC_INSTRUMENT_PROGRAM_FLOW_ARCS'</span>] = <span class="string">'YES'</span></span><br><span class="line">        config.build_settings[<span class="string">'GCC_GENERATE_TEST_COVERAGE_FILES'</span>] = <span class="string">'YES'</span></span><br><span class="line">        project.save()</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>编译时采集gcno文件。</li></ul><p>gcno包含了代码计数器和源码的映射关系，编译之后就会生成，具体目录如下。<br>不同架构下的编译产物目录根据PLATFORM_PREFERRED_ARCH不同而有所区别。<br>ps: OBJECT_FILE_DIR_normal和PLATFORM_PREFERRED_ARCH是Xcode编译时的环境变量，可以在运行xcodebuild时加上-showBuildSettings来查看所有环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJECT_FILE_DIR_normal/PLATFORM_PREFERRED_ARCH</span><br></pre></td></tr></table></figure><ul><li>运行时采集gcda文件。<br>gcda 记录了每段代码具体的执行次数，运行时产生，具体生成的目录需要自己指定。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line">    <span class="built_in">NSString</span> *coverageDir = [<span class="keyword">self</span> coverageDir];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"coverage path:%@"</span>, coverageDir);</span><br><span class="line">    setenv(<span class="string">"GCOV_PREFIX"</span>, [coverageDir cStringUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span>], <span class="number">1</span>);</span><br><span class="line">    setenv(<span class="string">"GCOV_PREFIX_STRIP"</span>, <span class="string">"11"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>在应用进入后台或者其他时机，可以选择主动调用__gcov_flush();来刷新本地的覆盖率数据。<br>在实际操作中，我们对模拟器和真机采取不同策略，模拟器因为沙盒目录其实就在mac本地，所以我们把gcda移动到我们的工作目录，编译后面生成覆盖率数据。真机我们选择将gcda上传到文件服务器，需要的时候从服务器拉下来辅助我们产生覆盖率数据。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    __gcov_flush();</span><br><span class="line"><span class="meta">#if TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">    [<span class="keyword">self</span> flushToNative];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    [<span class="keyword">self</span> flushToRemote];</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><blockquote><p>当写入gcda内容时，如果发生写入的内容和文件中已有的内容有冲突，我们需要先删除本地原来的文件。将Apple源码中GCDAProfiling.c拷贝入自己的工程，对其中写入gcda代码作修改即可。</p></blockquote><ul><li>运行完触发全量覆盖率的生生成。</li></ul><p>全量覆盖率的产生需要借助<a href="https://manpages.debian.org/unstable/lcov/lcov.1.en.html" target="_blank" rel="noopener">lcov</a>和<a href="https://manpages.debian.org/unstable/lcov/genhtml.1.en.html" target="_blank" rel="noopener">genhtml</a>。lcov帮我们生成中间文件info，包含了所有的代码信息和覆盖率信息，genhtml帮我们将info文件转换成可视化html。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成info文件</span></span><br><span class="line">lcov --capture --directory &#123;gcda目录&#125; --base-directory &#123;源代码目录&#125; --output-file &#123;指定生成的info文件地址&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成html</span></span><br><span class="line">genhtml &#123;生成的info文件地址&#125; --output-directory &#123;指定生成的报告目录&#125;</span><br></pre></td></tr></table></figure><h3 id="获取代码diff信息"><a href="#获取代码diff信息" class="headerlink" title="获取代码diff信息"></a>获取代码diff信息</h3><p>Diff的获取相对简单，我们平常用git就可以拿到，如果用脚本，可以参考以下代码。<br>因为我们最终目的是增量覆盖率，所以我们在这里的核心其实就是拿到git记录中，行前面有+的行信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> git</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">get_diff</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""获取diff详情"""</span></span><br><span class="line">        repository = git.Repo(self.repo_path)</span><br><span class="line">        diff = repository.git.diff(self.dst_commit, self.src_commit).split(<span class="string">"\n"</span>)</span><br><span class="line">        ret = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        file_name = <span class="string">""</span></span><br><span class="line">        diff_lines = []</span><br><span class="line">        current_line = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> diff:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">'diff --git'</span>):</span><br><span class="line">                <span class="comment"># 进入新的block</span></span><br><span class="line">                <span class="keyword">if</span> file_name != <span class="string">""</span>:</span><br><span class="line">                    ret[file_name] = diff_lines</span><br><span class="line">                tmp_result = re.findall(<span class="string">'b/(\S+)$'</span>, line)</span><br><span class="line">                <span class="keyword">if</span> tmp_result:</span><br><span class="line">                    file_name = tmp_result[<span class="number">0</span>]</span><br><span class="line">                    diff_lines = []</span><br><span class="line">                    current_line = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> re.match(<span class="string">'@@ -\d+,\d+ \+(\d+),\d+ @@'</span>, line):</span><br><span class="line">                match = re.match(<span class="string">'@@ -\d+,\d+ \+(\d+),\d+ @@'</span>, line)</span><br><span class="line">                current_line = int(match.group(<span class="number">1</span>)) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> line.startswith(<span class="string">"-"</span>) <span class="keyword">and</span> <span class="keyword">not</span> line.startswith(<span class="string">'---'</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> line.startswith(<span class="string">"+"</span>) <span class="keyword">and</span> <span class="keyword">not</span> line.startswith(<span class="string">'+++'</span>):</span><br><span class="line">                current_line += <span class="number">1</span></span><br><span class="line">                diff_lines.append(current_line)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_line += <span class="number">1</span></span><br><span class="line">        ret[file_name] = diff_lines</span><br><span class="line">        change_list = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> ret.iteritems():</span><br><span class="line">            change_list.append((key, value))</span><br><span class="line">        <span class="keyword">return</span> change_list</span><br></pre></td></tr></table></figure><h3 id="获取增量覆盖率"><a href="#获取增量覆盖率" class="headerlink" title="获取增量覆盖率"></a>获取增量覆盖率</h3><p>现在我们拿到了全量覆盖率，同时也拿到了增量的代码行信息，怎么才能从中过滤出增量的代码覆盖率？<br>如果从最终的html入手去过滤，肯定是费时费力而且不稳定的，那么往前一步，我们在生成html之前有生成一个.info的文件，通过<a href="https://manpages.debian.org/unstable/lcov/geninfo.1.en.html" target="_blank" rel="noopener">geninfo</a>文档我们可以看出，这个文件包含了所有代码的信息以及代码运行的信息，这正是我们需要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">TN:&lt;test name&gt;</span><br><span class="line"></span><br><span class="line">For each source file referenced in the .da file, there is a section containing filename and coverage data:</span><br><span class="line"></span><br><span class="line">SF:&lt;absolute path to the source file&gt;</span><br><span class="line"></span><br><span class="line">Following is a list of line numbers for each function name found in the source file:</span><br><span class="line"></span><br><span class="line">FN:&lt;line number of function start&gt;,&lt;function name&gt;</span><br><span class="line"></span><br><span class="line">Next, there is a list of execution counts for each instrumented function:</span><br><span class="line"></span><br><span class="line">FNDA:&lt;execution count&gt;,&lt;function name&gt;</span><br><span class="line"></span><br><span class="line">This list is followed by two lines containing the number of functions found and hit:</span><br><span class="line"></span><br><span class="line">FNF:&lt;number of functions found&gt; FNH:&lt;number of function hit&gt;</span><br><span class="line"></span><br><span class="line">Branch coverage information is stored which one line per branch:</span><br><span class="line"></span><br><span class="line">BRDA:&lt;line number&gt;,&lt;block number&gt;,&lt;branch number&gt;,&lt;taken&gt;</span><br><span class="line"></span><br><span class="line">Block number and branch number are gcc internal IDs for the branch. Taken is either &apos;-&apos; if the basic block containing the branch was never executed or a number indicating how often that branch was taken.</span><br><span class="line"></span><br><span class="line">Branch coverage summaries are stored in two lines:</span><br><span class="line"></span><br><span class="line">BRF:&lt;number of branches found&gt; BRH:&lt;number of branches hit&gt;</span><br><span class="line"></span><br><span class="line">Then there is a list of execution counts for each instrumented line (i.e. a line which resulted in executable code):</span><br><span class="line"></span><br><span class="line">DA:&lt;line number&gt;,&lt;execution count&gt;[,&lt;checksum&gt;]</span><br><span class="line"></span><br><span class="line">Note that there may be an optional checksum present for each instrumented line. The current geninfo implementation uses an MD5 hash as checksumming algorithm.</span><br><span class="line"></span><br><span class="line">At the end of a section, there is a summary about how many lines were found and how many were actually instrumented:</span><br><span class="line"></span><br><span class="line">LH:&lt;number of lines with a non-zero execution count&gt; LF:&lt;number of instrumented lines&gt;</span><br><span class="line"></span><br><span class="line">Each sections ends with:</span><br><span class="line"></span><br><span class="line">end_of_record</span><br></pre></td></tr></table></figure><p>所以我们只要解析出info文件，然后通过增量代码的行信息，从info文件中过滤出所有增量代码及其相关覆盖信息，就可以达到我们的效果。</p><ul><li>解析info文件</li></ul><p>这里参考我写的脚本<a href="https://github.com/shanksGuo/InfoParser" target="_blank" rel="noopener">Script</a></p><ul><li>过滤出增量代码重新生成info。</li></ul><p>这里在上一步的脚本中有相关代码，主要是标记info解析出的func是否是diff的方法，最终通过record的to_diff_info重新生成info文件。</p><ul><li>运用genhtml重新生成html。</li></ul><p>这一步还是和全量覆盖率中一致。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在以上方案中，当多次运行代码，如果代码产生的覆盖率信息有冲突，__gcov_flush();的刷新策略不会将其覆盖，所以如果前后两次代码如果有冲突，很可能我们需要删掉App重新运行，这将是很费劲的。<br>所以我们将llvm的GCDAProfiling.c源码拿来，对覆盖刷新的部分做修改，如果有冲突则删除上一份保留最新的。<br>因为覆盖率插桩是编译器做的，实际运行时也会用到GCDAProfiling，所以我们这样做其实替换了插桩代码用到的GCDAProfiling。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里大致叙述了做增量覆盖率时的一些思路，想把整个流程做完善并且易于使用，还是需要结合自己工程和开发流程做一些工作，才能让这个工具易用方便。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://tech.meituan.com/2018/12/27/ios-increment-coverage.html" target="_blank" rel="noopener">美团</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是增量覆盖率&quot;&gt;&lt;a href=&quot;#什么是增量覆盖率&quot; class=&quot;headerlink&quot; title=&quot;什么是增量覆盖率&quot;&gt;&lt;/a&gt;什么是增量覆盖率&lt;/h2&gt;&lt;p&gt;增量覆盖率，顾名思义，指的是每次代码改动的增量部分，开发自测的覆盖程度。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要增量覆盖率&quot;&gt;&lt;a href=&quot;#为什么需要增量覆盖率&quot; class=&quot;headerlink&quot; title=&quot;为什么需要增量覆盖率&quot;&gt;&lt;/a&gt;为什么需要增量覆盖率&lt;/h2&gt;&lt;p&gt;大型项目为了持续保证代码和App的质量，需要对新引入代码进行审查，而在代码被合并进去之前（比如在code review阶段），增量覆盖率无疑是衡量开发对代码的自测重复程度的一个很好的指标。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码覆盖率不是万能的，只能通过这个手段解决一部分明显通过自测就可以发现的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;增量代码覆盖率更偏向于开发使用，保证开发自测的充分程度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="增量" scheme="www.shanks.pro/tags/%E5%A2%9E%E9%87%8F/"/>
    
      <category term="覆盖率" scheme="www.shanks.pro/tags/%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
      <category term=".info" scheme="www.shanks.pro/tags/info/"/>
    
      <category term="lcov" scheme="www.shanks.pro/tags/lcov/"/>
    
  </entry>
  
  <entry>
    <title>浅析.framework的生成</title>
    <link href="www.shanks.pro/2019/04/09/framework-parse/"/>
    <id>www.shanks.pro/2019/04/09/framework-parse/</id>
    <published>2019-04-09T02:22:56.000Z</published>
    <updated>2019-04-09T05:27:27.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近项目需要将在独立仓库生成的.framework集成进来，同时又希望是static framwork，原因是动态framework在启动时链接会消耗启动时间，这是我们不想看到的。而我们自己独立仓库使用的cocoapods管理，使用cocoapods-packager打出来的framework没有将Resources单独分开，导致带资源bundle的framework被静态链接时会被Testflight打回（正常编译没问题）。<br>所以我们要做的就是将cocoapods-packager生成的static framework中资源剥离开单独在Build Phases中设置。当然，从生成framwork，到剥离Resources，再到集成项目设置都是在我们CI中自动化实现。</p><a id="more"></a><h2 id="framework是什么"><a href="#framework是什么" class="headerlink" title="framework是什么"></a>framework是什么</h2><p>要把Resources从framework中拆分出来，要先弄清楚framework是什么。从苹果官方文档可以找到答案。</p><blockquote><p>A framework is a hierarchical directory that encapsulates shared resources, such as a dynamic shared library, nib files, image files, localized strings, header files, and reference documentation in a single package. Multiple applications can use all of these resources simultaneously. The system loads them into memory as needed and shares the one copy of the resource among all applications whenever possible.</p></blockquote><p>简单来说，一个framework就是一个多层目录，包含代码(library)，头文件(header files)和资源(nib, image, localized strings)。<br>从苹果的文档中也可以看到，framework的层级大致如下。其中MyFramework和Resources并非实体目录，而知识一个symbol link，连接到Versions/Current下面的MyFramework和Resources。Current也是一个symbol link，链接到A。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MyFramework.framework/</span><br><span class="line">    MyFramework  -&gt; Versions/Current/MyFramework</span><br><span class="line">    Resources    -&gt; Versions/Current/Resources</span><br><span class="line">    Versions/</span><br><span class="line">        A/</span><br><span class="line">            MyFramework</span><br><span class="line">            Resources/</span><br><span class="line">                English.lproj/</span><br><span class="line">                    InfoPlist.strings</span><br><span class="line">                Info.plist</span><br><span class="line">        Current  -&gt; A</span><br></pre></td></tr></table></figure><p>上述内容可以通过命令验证，我们新建了一个framework，通过ls -l可以看到结果。</p><p><img src="/assets/performance-ls-1.jpg" alt="alt text"></p><p><img src="/assets/performance-ls-2.jpg" alt="alt text"></p><p>至于为什么要搞这么复杂，需要link到Current再link到A，可以自行参考文末文档。</p><h2 id="cocoapods-packager怎么做的"><a href="#cocoapods-packager怎么做的" class="headerlink" title="cocoapods-packager怎么做的"></a>cocoapods-packager怎么做的</h2><p>知道了framework只是一个目录，那把Resources直接从framework中移动出来应该就能解决问题。但总有些不放心，所以我们再看下cocoapods-packager是怎么生成framwork的。</p><p>cocoapods-packager生成framework大致分以下几个步骤。</p><ol><li>编译代码，这是为了检验代码正确性。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span></span></span><br><span class="line">    defines = <span class="string">"GCC_PREPROCESSOR_DEFINITIONS='$(inherited) PodsDummy_Pods_<span class="subst">#&#123;@spec.name&#125;</span>=PodsDummy_PodPackage_<span class="subst">#&#123;@spec.name&#125;</span>'"</span></span><br><span class="line">    defines &lt;&lt; <span class="string">' '</span> &lt;&lt; @spec.consumer(@platform).compiler_flags.join(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> @platform.name == <span class="symbol">:ios</span></span><br><span class="line">    options = ios_build_options</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    xcodebuild(defines, options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> @mangle</span><br><span class="line">    <span class="keyword">return</span> build_with_mangling(options)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    defines</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建framwork目录，以及Headers, Resources等子目录</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_framework</span></span></span><br><span class="line">    @fwk = Framework::Tree.new(@spec.name, @platform.name.to_s, @embedded)</span><br><span class="line">    @fwk.make</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make</span></span></span><br><span class="line">    make_root</span><br><span class="line">    make_framework</span><br><span class="line">    make_headers</span><br><span class="line">    make_resources</span><br><span class="line">    make_current_version</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_current_version</span></span></span><br><span class="line">    current_version_path = @versions_path + Pathname.new(<span class="string">'../Current'</span>)</span><br><span class="line">    <span class="string">`ln -sf A <span class="subst">#&#123;current_version_path&#125;</span>`</span></span><br><span class="line">    <span class="string">`ln -sf Versions/Current/Headers <span class="subst">#&#123;@fwk_path&#125;</span>/`</span></span><br><span class="line">    <span class="string">`ln -sf Versions/Current/Resources <span class="subst">#&#123;@fwk_path&#125;</span>/`</span></span><br><span class="line">    <span class="string">`ln -sf Versions/Current/<span class="subst">#&#123;@name&#125;</span> <span class="subst">#&#123;@fwk_path&#125;</span>/`</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>值得一提的是，创建完目录有个link的过程，是通过ls -sf src target来创建symbol link，这点和我们之前说到的一致。</p><ol start="3"><li>生成静态library</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_static_library_for_ios</span><span class="params">(output)</span></span></span><br><span class="line">    static_libs = static_libs_in_sandbox(<span class="string">'build'</span>) + static_libs_in_sandbox(<span class="string">'build-sim'</span>) + vendored_libraries</span><br><span class="line">    libs = ios_architectures.map <span class="keyword">do</span> <span class="params">|arch|</span></span><br><span class="line">      library = <span class="string">"<span class="subst">#&#123;@static_sandbox_root&#125;</span>/build/package-<span class="subst">#&#123;arch&#125;</span>.a"</span></span><br><span class="line">      <span class="string">`libtool -arch_only <span class="subst">#&#123;arch&#125;</span> -static -o <span class="subst">#&#123;library&#125;</span> <span class="subst">#&#123;static_libs.join(<span class="string">' '</span>)&#125;</span>`</span></span><br><span class="line">      library</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="string">`lipo -create -output <span class="subst">#&#123;output&#125;</span> <span class="subst">#&#123;libs.join(<span class="string">' '</span>)&#125;</span>`</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>先单独对每种架构生成.a，再将所有合并生成一个universal library。</p><ol start="4"><li>拷贝头文件,license和资源</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_static_framework</span></span></span><br><span class="line">  <span class="comment"># ....</span></span><br><span class="line"></span><br><span class="line">  copy_headers</span><br><span class="line">  copy_license</span><br><span class="line">  copy_resources</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里做的就是将之前编译产物里的头文件，license和资源拷贝到framework目录下，代码就不赘述。</p><h2 id="资源分离方案"><a href="#资源分离方案" class="headerlink" title="资源分离方案"></a>资源分离方案</h2><p>通过苹果官方文档和对cocoapods-packager源码的分析，我们可以确定framework其实就是一种特殊的目录结构，所以想要达到我们的目的，将资源从中分离出来，要做的其实就是文件和目录的操作。</p><ol><li>删除framework根目录中Resources的symbol link</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm xxx.framework/Resources</span><br></pre></td></tr></table></figure><ol start="2"><li>移动Versions/A/Resources里面的内容，并且删除Versions/A/Resources目录</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(resource_dir):</span><br><span class="line">    file_path = os.path.join(resource_dir, filename)</span><br><span class="line">    LOG.info(<span class="string">"move file: &#123;&#125; to target dir: &#123;&#125;"</span>.format(file_path, target_path))</span><br><span class="line">    shutil.move(file_path, target_path)</span><br><span class="line">shutil.rmtree(resource_dir)</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183-SW1" target="_blank" rel="noopener">What are Frameworks</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;最近项目需要将在独立仓库生成的.framework集成进来，同时又希望是static framwork，原因是动态framework在启动时链接会消耗启动时间，这是我们不想看到的。而我们自己独立仓库使用的cocoapods管理，使用cocoapods-packager打出来的framework没有将Resources单独分开，导致带资源bundle的framework被静态链接时会被Testflight打回（正常编译没问题）。&lt;br&gt;所以我们要做的就是将cocoapods-packager生成的static framework中资源剥离开单独在Build Phases中设置。当然，从生成framwork，到剥离Resources，再到集成项目设置都是在我们CI中自动化实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="framework" scheme="www.shanks.pro/categories/framework/"/>
    
    
      <category term="framework" scheme="www.shanks.pro/tags/framework/"/>
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="ruby" scheme="www.shanks.pro/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>记一次ReactNative的多线程crash</title>
    <link href="www.shanks.pro/2019/02/18/react-native-imageloader-crash/"/>
    <id>www.shanks.pro/2019/02/18/react-native-imageloader-crash/</id>
    <published>2019-02-18T13:53:03.000Z</published>
    <updated>2019-03-07T09:03:25.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用ReactNative v0.51版本时，发现线上有个崩溃一直没有解决，为了完成App治理crash的目标，所以花了点时间研究如何解决这个问题。<br><a id="more"></a></p><h2 id="Crash介绍"><a href="#Crash介绍" class="headerlink" title="Crash介绍"></a>Crash介绍</h2><p><img src="/assets/rn-crash-reccomend.png" alt="alt text"></p><p><img src="/assets/rn-crash-distribute.png" alt="alt text"></p><p>可以看到如下信息</p><ol><li>崩溃位置</li></ol><blockquote><p>[RCTHTTPRequestHandler sendRequest:withDelegate:]</p></blockquote><ol start="2"><li>崩溃线程</li></ol><blockquote><p>#27 Thread - 子线程</p></blockquote><ol start="3"><li>崩溃原因</li></ol><blockquote><p>NSGenericException</p></blockquote><ol start="4"><li>崩溃描述</li></ol><blockquote><p>Task created in a session that has been invalidated</p></blockquote><ol start="5"><li>崩溃分布</li></ol><blockquote><p>没有很明显的特征</p></blockquote><h2 id="直接崩溃原因"><a href="#直接崩溃原因" class="headerlink" title="直接崩溃原因"></a>直接崩溃原因</h2><p>根据崩溃原因NSGenericException，可以知道这是一个OC异常。我们先尝试找到直接导致崩溃的原因是什么，再找到真正触发的条件。</p><p>根据描述”Task created in a session that has been invalidated”，大概能看出一个失效的session对象尝试去创建task导致异常，而sendRequest:withDelegate:方法中创建task的地方只有一个</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSession</span> *_session;</span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)sendRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                         withDelegate:(<span class="keyword">id</span>&lt;RCTURLRequestDelegate&gt;)delegate &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="built_in">NSURLSessionDataTask</span> *task = [_session dataTaskWithRequest:request];</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而session为什么会invalidate的原因也很简单，因为[NSURLSession invalidateAndCancel].</p><p><img src="/assets/rn-crash-invalidate.png" alt="alt text"></p><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><p>知道直接崩溃原因，我们就要找到触发崩溃的原因。根据上面的证据，我们推测RCTHTTPRequestHandler肯定调用了invalidateAndCancel，事实也正是这样。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTHTTPRequestHandler.mm</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">  [_session invalidateAndCancel];</span><br><span class="line">  _session = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果_session被置为nil，则不会发生问题，所以肯定是[_session invalidateAndCancel]和_session = nil执行之间被打断了，结合之前的堆栈信息，卡顿发生在子线程，基本可以肯定这是一个多线程的问题，导致[RCTHTTPRequestHandler invalidate]的方法执行没有保证原子性。</p><p>那我们就要找出sendRequest:withDelegate:和invalidate各自的调用链。</p><h3 id="sendRequest"><a href="#sendRequest" class="headerlink" title="sendRequest"></a>sendRequest</h3><p><img src="/assets/rn-crash-imageloader.png" alt="alt text"></p><p>根据崩溃堆栈，我们可以看到sendRequest是在RCTImageLoader中发起的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_URLRequestQueue = dispatch_queue_create(<span class="string">"com.facebook.react.ImageLoaderURLRequestQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dequeueTasks</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(_URLRequestQueue, ^&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        [task start];</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以sendRequest是在名为”com.facebook.react.ImageLoaderURLRequestQueue”的串行队列中执行.</p><h3 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h3><p>通过源码，可以找到invalidate的调用路径</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-&gt;RCTBridge.dealloc</span></span><br><span class="line"><span class="comment">-&gt;RCTBridge.invalidate</span></span><br><span class="line"><span class="comment">-&gt;RCTCxxBridge.invalidate</span></span><br><span class="line"><span class="comment">-&gt;[moduleData.instance invalidate]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">  <span class="comment">//...省略</span></span><br><span class="line">  <span class="keyword">if</span> ([moduleData.instance respondsToSelector:<span class="keyword">@selector</span>(invalidate)]) &#123;</span><br><span class="line">    dispatch_group_enter(moduleInvalidation);</span><br><span class="line">    [<span class="keyword">self</span> dispatchBlock:^&#123;</span><br><span class="line">      [(<span class="keyword">id</span>&lt;RCTInvalidating&gt;)moduleData.instance invalidate];</span><br><span class="line">      dispatch_group_leave(moduleInvalidation);</span><br><span class="line">    &#125; queue:moduleData.methodQueue];</span><br><span class="line">  &#125;</span><br><span class="line">  [moduleData invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://shanks.pro/2019/01/10/react-native-communication/" target="_blank" rel="noopener">RN原理</a>， 可以知道moduleData是在RN初始化的时候注册的模块信息，RCTHTTPRequestHandler也会生成其中一个moduleData。 那我们看下moduleData.methodQueue是什么，因为这就是invalidate执行的队列。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUpMethodQueue &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  _queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"com.facebook.react.%@Queue"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">    _methodQueue = dispatch_queue_create(_queueName.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"> [(<span class="keyword">id</span>)_instance setValue:_methodQueue forKey:<span class="string">@"methodQueue"</span>];</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，每个module都会又一个对应的串行methodQueue，并且名称的规则是”com.facebook.react.%@Queue”, 所以RCTHTTPRequestHandler对应的队列就是”com.facebook.react.HTTPRequestHandlerQueue”</p><p>也即，invalidate是在串行队列””com.facebook.react.HTTPRequestHandlerQueue””中执行。</p><h3 id="还不够！"><a href="#还不够！" class="headerlink" title="还不够！"></a>还不够！</h3><p>就算知道了sendRequest和invalidate方法在不同队列的线程中执行，还不能百分百确定一定会发生多线程问题，除非RCTCxxBridge.invalidate中触发的moduleData实例和RCTImageLoader触发的sendRequest中RCTHTTPRequestHandler实例是同一个对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTNetworkTask中获取RCTHTTPRequestHandler的方法</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;RCTURLRequestHandler&gt;)handlerForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">  _handlers = [[<span class="keyword">self</span>.bridge modulesConformingToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">RCTURLRequestHandler</span>)] <span class="title">sortedArrayUsingComparator</span>:^<span class="title">NSComparisonResult</span>(<span class="title">id</span>&lt;<span class="title">RCTURLRequestHandler</span>&gt; <span class="title">a</span>, <span class="title">id</span>&lt;<span class="title">RCTURLRequestHandler</span>&gt; <span class="title">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> priorityA = [a respondsToSelector:<span class="keyword">@selector</span>(handlerPriority)] ? [a handlerPriority] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> priorityB = [b respondsToSelector:<span class="keyword">@selector</span>(handlerPriority)] ? [b handlerPriority] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (priorityA &gt; priorityB) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">NSOrderedAscending</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priorityA &lt; priorityB) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">NSOrderedDescending</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">NSOrderedSame</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTBridge.m</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)modulesConformingToProtocol:(Protocol *)protocol</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSMutableArray</span> *modules = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">  <span class="keyword">for</span> (Class moduleClass <span class="keyword">in</span> [<span class="keyword">self</span>.moduleClasses <span class="keyword">copy</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([moduleClass conformsToProtocol:protocol]) &#123;</span><br><span class="line">      <span class="keyword">id</span> module = [<span class="keyword">self</span> moduleForClass:moduleClass];</span><br><span class="line">      <span class="keyword">if</span> (module) &#123;</span><br><span class="line">        [modules addObject:module];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [modules <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，RCTNetworkTask执行时用到的handler，是从RCTBridge之前注册好的module中去找到符合<rcturlrequesthandler>协议的对象。最终结果找到也是RCTHTTPRequestHandler对象。</rcturlrequesthandler></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCTHTTPRequestHandler</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTURLRequestHandler</span>, <span class="title">RCTInvalidating</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>至此可以发现，RCTHTTPRequestHandler其实生成的实例对象，在一个RCTBridge周期内只有一个。同一个RCTHTTPRequestHandler对象的invalidate和sendRequest的执行在不同队列的不同子线程。虽然两个队列都是串行，但是两个子线程之间互相之间没有约束，一个执行时可能会被另一个打断，从而导致执行了[_session invalidateAndCancel]之后执行[_session dataTaskWithRequest:request]导致crash。</p><h2 id="怎么复现"><a href="#怎么复现" class="headerlink" title="怎么复现"></a>怎么复现</h2><p>我复现的方式是，在RCTHTTPRequestHandler的invalidate方法中插入sleep，加大RCTHTTPRequestHandler中invalidate方法被打断的概率，同时在外面模拟RCTBridge的invalidate。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTHTTPRequestHandler</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">  [_session invalidateAndCancel];</span><br><span class="line">  sleep(<span class="number">3</span>);</span><br><span class="line">  _session = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样很容易能复现这个问题。</p><h2 id="怎么修复"><a href="#怎么修复" class="headerlink" title="怎么修复"></a>怎么修复</h2><p>既然两个线程在不同的队列执行，那最简单的修复方式就是把他们的执行放到同一个队列中去，这样两块代码再执行的时候顺序不会被中途打断。<br>之前我们也看到，每个moduleData都有自己的methodQueue，那比较好的方式还是在RCTHTTPRequestHandler内部用他自己的methodQueue。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synthesize</span> methodQueue = _methodQueue;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidate&#123;</span><br><span class="line">  <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>-&gt;_methodQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span>-&gt;_session invalidateAndCancel];</span><br><span class="line">    <span class="keyword">self</span>-&gt;_session = <span class="literal">nil</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)sendRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                         withDelegate:(<span class="keyword">id</span>&lt;RCTURLRequestDelegate&gt;)delegate &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>-&gt;_methodQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span>-&gt;session dataTaskWithRequest:request];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给ReactNative提PR"><a href="#给ReactNative提PR" class="headerlink" title="给ReactNative提PR"></a>给ReactNative提PR</h2><p>既然这里存在问题，并且改动还算合理，我就尝试把这个修改提交给ReactNative，看人家会不会采纳。最终PR还是被合并了，Bingo!<br><a href="https://github.com/facebook/react-native/pull/22746" target="_blank" rel="noopener">https://github.com/facebook/react-native/pull/22746</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个crash我们可以看到，多线程的问题比较隐蔽，所以我们平时在写代码和做code review时，要特别注意线程安全，对共享变量的使用要比较小心。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用ReactNative v0.51版本时，发现线上有个崩溃一直没有解决，为了完成App治理crash的目标，所以花了点时间研究如何解决这个问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="Crash" scheme="www.shanks.pro/categories/Crash/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="ReactNative" scheme="www.shanks.pro/tags/ReactNative/"/>
    
      <category term="MultiThread" scheme="www.shanks.pro/tags/MultiThread/"/>
    
      <category term="Crash" scheme="www.shanks.pro/tags/Crash/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码分析-通信机制(基于iOS)</title>
    <link href="www.shanks.pro/2019/01/10/react-native-communication/"/>
    <id>www.shanks.pro/2019/01/10/react-native-communication/</id>
    <published>2019-01-10T05:40:45.000Z</published>
    <updated>2019-03-07T09:29:42.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备-JavaScriptCore"><a href="#准备-JavaScriptCore" class="headerlink" title="准备-JavaScriptCore"></a>准备-JavaScriptCore</h2><p>在开篇，我们先简单准备下JavaScriptCore的知识。这是整个Native和JS沟通的最底层的桥梁。<br><a id="more"></a></p><p><strong><em>Classes</em></strong></p><ul><li><p>JSContext <br><br>JS的执行上下文<br><br><img src="/assets/jscontext.jpg" alt=""></p></li><li><p>JSManagedValue<br><br>主要用于防止Native导出对象时持有JSValue导致循环引用</p></li><li><p>JSValue<br><br>JavaScript值的引用，转换JavaScript和Native之间的基本数据<br><br><img src="/assets/jsvalue.jpg" alt=""></p></li><li><p>JSVirtualMachine<br><br>提供JS执行环境<br><br><img src="/assets/jsvm.jpg" alt=""></p></li><li><p>JSExport<br><br>导出Native到JavaScript</p></li></ul><p><strong><em>相对应的底层C实现</em></strong></p><ul><li>JSBase</li><li>JSContextRef</li><li>JSObjectRef</li><li>JSStringRef</li><li>JSStringRefCF</li><li>JSValueRef</li></ul><h2 id="ReactNative通信原理"><a href="#ReactNative通信原理" class="headerlink" title="ReactNative通信原理"></a>ReactNative通信原理</h2><p>从ReactNative的demo开始，入口我们只看到两个东西RCTRootView和RCTBridge。RCTRootView负责展示，RCTBridge则和ReactNative的通信有关。</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(__unused <span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">  _bridge = [[RCTBridge alloc] initWithDelegate:<span class="keyword">self</span></span><br><span class="line">                                  launchOptions:launchOptions];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:_bridge</span><br><span class="line">                                                   moduleName:<span class="string">@"RNTesterApp"</span></span><br><span class="line">                                            initialProperties:initProps];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">  <span class="built_in">UIViewController</span> *rootViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">  rootViewController.view = rootView;</span><br><span class="line">  <span class="keyword">self</span>.window.rootViewController = rootViewController;</span><br><span class="line">  [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RCTCxxBridge初始化"><a href="#RCTCxxBridge初始化" class="headerlink" title="RCTCxxBridge初始化"></a>RCTCxxBridge初始化</h3><p>跟着调用链会看到，bridge的初始化会走到RCTCxxBridge中的start<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTCxxBrige.mm</span></span><br><span class="line"><span class="comment">//只贴了关键代码</span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">  dispatch_group_t prepareBridge = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化native modules</span></span><br><span class="line">  (<span class="keyword">void</span>)[<span class="keyword">self</span> _initializeModules:RCTGetModuleClasses() withDispatchGroup:prepareBridge lazilyDiscovered:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化底层Instance</span></span><br><span class="line">  dispatch_group_enter(prepareBridge);</span><br><span class="line">  [<span class="keyword">self</span> ensureOnJavaScriptThread:^&#123;</span><br><span class="line">    [weakSelf _initializeBridge:executorFactory];</span><br><span class="line">    dispatch_group_leave(prepareBridge);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载js代码</span></span><br><span class="line">  dispatch_group_enter(prepareBridge);</span><br><span class="line">  __block <span class="built_in">NSData</span> *sourceCode;</span><br><span class="line">  [<span class="keyword">self</span> loadSource:^(<span class="built_in">NSError</span> *error, RCTSource *source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      [weakSelf handleError:error];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceCode = source.data;</span><br><span class="line">    dispatch_group_leave(prepareBridge);</span><br><span class="line">  &#125; onProgress:^(RCTLoadingProgress *progressData) &#123;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行js代码</span></span><br><span class="line">  dispatch_group_notify(prepareBridge, dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, <span class="number">0</span>), ^&#123;</span><br><span class="line">    RCTCxxBridge *strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (sourceCode &amp;&amp; strongSelf.loading) &#123;</span><br><span class="line">      [strongSelf executeSourceCode:sourceCode sync:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>start方法里做了这么几件事：</p><ul><li>初始化native modules</li><li>初始化Instance-&gt;底层负责通信</li><li>加载本地js</li></ul><p>要想了解native modules的初始化，我们要先看下之前的准备工作。</p><h3 id="native-modules导出模块"><a href="#native-modules导出模块" class="headerlink" title="native modules导出模块"></a>native modules导出模块</h3><p>通过RCT_EXPORT_MODULE将本地的模块导出供JS使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTBridgeModule.h</span></span><br><span class="line"><span class="meta">#define RCT_EXPORT_MODULE(js_name) \</span></span><br><span class="line">RCT_EXTERN <span class="keyword">void</span> RCTRegisterModule(Class); \</span><br><span class="line">+ (<span class="built_in">NSString</span> *)moduleName &#123; <span class="keyword">return</span> @<span class="meta">#js_name; &#125; \</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123; RCTRegisterModule(<span class="keyword">self</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RCTRegisterModule(Class moduleClass) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    RCTModuleClasses = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    RCTModuleClassesSyncQueue = dispatch_queue_create(<span class="string">"com.facebook.react.ModuleClassesSyncQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  &#125;);</span><br><span class="line">  dispatch_barrier_async(RCTModuleClassesSyncQueue, ^&#123;</span><br><span class="line">    [RCTModuleClasses addObject:moduleClass];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终导出的模块会被保存到RCTModuleClasses，使用时通过RCTGetModuleClasses()获取。RCTGetModuleClasses()就是在上面初始化native modules时用到的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTBridge.m</span></span><br><span class="line"><span class="built_in">NSArray</span>&lt;Class&gt; *RCTGetModuleClasses(<span class="keyword">void</span>) &#123;</span><br><span class="line">  __block <span class="built_in">NSArray</span>&lt;Class&gt; *result;</span><br><span class="line">  <span class="built_in">dispatch_sync</span>(RCTModuleClassesSyncQueue, ^&#123;</span><br><span class="line">    result = [RCTModuleClasses <span class="keyword">copy</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="native-modules导出方法"><a href="#native-modules导出方法" class="headerlink" title="native modules导出方法"></a>native modules导出方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTBridgeModule.h</span></span><br><span class="line"><span class="meta">#define RCT_EXPORT_METHOD(method) \</span></span><br><span class="line">  RCT_REMAP_METHOD(, method)</span><br><span class="line"></span><br><span class="line"><span class="meta">#define RCT_REMAP_METHOD(js_name, method) \</span></span><br><span class="line">  _RCT_EXTERN_REMAP_METHOD(js_name, method, <span class="literal">NO</span>) \</span><br><span class="line">  - (<span class="keyword">void</span>)method RCT_DYNAMIC;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define _RCT_EXTERN_REMAP_METHOD(js_name, method, is_blocking_synchronous_method) \</span></span><br><span class="line">  + (<span class="keyword">const</span> RCTMethodInfo *)RCT_CONCAT(__rct_export__, RCT_CONCAT(js_name, RCT_CONCAT(__LINE__, __COUNTER__))) &#123; \</span><br><span class="line">    <span class="keyword">static</span> RCTMethodInfo config = &#123;<span class="meta">#js_name, #method, is_blocking_synchronous_method&#125;; \</span></span><br><span class="line">    <span class="keyword">return</span> &amp;config; \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>将方法导出，最终生成以下方法提供给外部调用。通过遍历这个类中所有以<br>“__rct_export__“开头的方法就可以获取属于这个类的所有导出方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTBridgeModule.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RCTMethodInfo &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> jsName;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> objcName;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">BOOL</span> isSync;</span><br><span class="line">&#125; RCTMethodInfo;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">const</span> RCTMethodInfo *)__rct_export__+js_name+__LINE__+__COUNTER__ &#123;</span><br><span class="line">    <span class="keyword">static</span> RCTMethodInfo config = &#123;</span><br><span class="line">        js_name,</span><br><span class="line">        method,</span><br><span class="line">        is_blocking_synchronous_method</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成RCTModuleData"><a href="#生成RCTModuleData" class="headerlink" title="生成RCTModuleData"></a>生成RCTModuleData</h3><p>初始化native modules的工作，其实就是根据之前导出的类和方法，生成对应的RCTModuleData对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;RCTModuleData *&gt; *)_registerModulesForClasses:(<span class="built_in">NSArray</span>&lt;Class&gt; *)moduleClasses</span><br><span class="line">                                        lazilyDiscovered:(<span class="built_in">BOOL</span>)lazilyDiscovered &#123;</span><br><span class="line">  <span class="built_in">NSArray</span> *moduleClassesCopy = [moduleClasses <span class="keyword">copy</span>];</span><br><span class="line">  <span class="built_in">NSMutableArray</span>&lt;RCTModuleData *&gt; *moduleDataByID = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:moduleClassesCopy.count];</span><br><span class="line">  <span class="keyword">for</span> (Class moduleClass <span class="keyword">in</span> moduleClassesCopy) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *moduleName = RCTBridgeModuleNameForClass(moduleClass);</span><br><span class="line">    RCTModuleData *moduleData = _moduleDataByName[moduleName];</span><br><span class="line">    <span class="keyword">if</span> (moduleData) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass bridge:<span class="keyword">self</span>];</span><br><span class="line">    _moduleDataByName[moduleName] = moduleData;</span><br><span class="line">    [_moduleClassesByID addObject:moduleClass];</span><br><span class="line">    [moduleDataByID addObject:moduleData];</span><br><span class="line">  &#125;</span><br><span class="line">  [_moduleDataByID addObjectsFromArray:moduleDataByID];</span><br><span class="line">  <span class="keyword">return</span> moduleDataByID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们完成了本地模块和方法的导出，并且生成了一组RCTModuleData对象来表示他们。</p><h3 id="初始化Instance"><a href="#初始化Instance" class="headerlink" title="初始化Instance"></a>初始化Instance</h3><p>我们继续看Instance的初始化。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化底层Instance</span></span><br><span class="line">  dispatch_group_enter(prepareBridge);</span><br><span class="line">  [<span class="keyword">self</span> ensureOnJavaScriptThread:^&#123;</span><br><span class="line">    [weakSelf _initializeBridge:executorFactory];</span><br><span class="line">    dispatch_group_leave(prepareBridge);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">  - (<span class="keyword">void</span>)_initializeBridge:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory &#123;</span><br><span class="line">  <span class="keyword">if</span> (_reactInstance) &#123;</span><br><span class="line">    [<span class="keyword">self</span> _initializeBridgeLocked:executorFactory];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">- (<span class="keyword">void</span>)_initializeBridgeLocked:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory &#123;</span><br><span class="line">  _reactInstance-&gt;initializeBridge(</span><br><span class="line">                                   std::make_unique&lt;RCTInstanceCallback&gt;(<span class="keyword">self</span>),</span><br><span class="line">                                   executorFactory,</span><br><span class="line">                                   _jsMessageThread,</span><br><span class="line">                                   [<span class="keyword">self</span> _buildModuleRegistryUnlocked]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Instance.cpp</span></span><br><span class="line"><span class="keyword">void</span> Instance::initializeBridge(</span><br><span class="line">    std::unique_ptr&lt;InstanceCallback&gt; callback,</span><br><span class="line">    std::shared_ptr&lt;JSExecutorFactory&gt; jsef,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue,</span><br><span class="line">    std::shared_ptr&lt;ModuleRegistry&gt; moduleRegistry) &#123;</span><br><span class="line">  callback_ = std::move(callback);</span><br><span class="line">  moduleRegistry_ = std::move(moduleRegistry);</span><br><span class="line"></span><br><span class="line">  jsQueue-&gt;runOnQueueSync([<span class="keyword">this</span>, &amp;jsef, jsQueue]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</span><br><span class="line">        jsef.get(), moduleRegistry_, jsQueue, callback_);</span><br><span class="line"></span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(m_syncMutex);</span><br><span class="line">    m_syncReady = <span class="literal">true</span>;</span><br><span class="line">    m_syncCV.notify_all();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化Instance需要一下几个元素：</p><ul><li><p>InstanceCallback类型的回调，用于底层执行结束后往上层回调。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> InstanceCallback &#123;</span><br><span class="line">  virtual ~InstanceCallback() &#123;&#125;</span><br><span class="line">  virtual <span class="keyword">void</span> onBatchComplete() &#123;&#125;</span><br><span class="line">  virtual <span class="keyword">void</span> incrementPendingJSCalls() &#123;&#125;</span><br><span class="line">  virtual <span class="keyword">void</span> decrementPendingJSCalls() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>JSExecutorFactory类型的对象，用于生成JSExecutor用于真正执行JS。生产返回使用的是JSCExecutorFactory，返回JSIExecutor用于执行JS，调试使用的是RCTObjcExecutorFactory,返回RCTObjcExecutor通过websocket链接chrome执行JS。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> JSExecutorFactory &#123;</span><br><span class="line">public:</span><br><span class="line">  virtual std::unique_ptr&lt;JSExecutor&gt; createJSExecutor(</span><br><span class="line">    std::shared_ptr&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue) = <span class="number">0</span>;</span><br><span class="line">  virtual ~JSExecutorFactory() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产</span></span><br><span class="line"><span class="keyword">class</span> JSCExecutorFactory : public JSExecutorFactory &#123;</span><br><span class="line">public:</span><br><span class="line">  std::unique_ptr&lt;JSExecutor&gt; createJSExecutor(</span><br><span class="line">    std::shared_ptr&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue) override &#123;</span><br><span class="line">    <span class="keyword">return</span> folly::make_unique&lt;JSIExecutor&gt;(</span><br><span class="line">      facebook::jsc::makeJSCRuntime(),</span><br><span class="line">      delegate,</span><br><span class="line">      [](<span class="keyword">const</span> std::string &amp;message, <span class="keyword">unsigned</span> <span class="keyword">int</span> logLevel) &#123;</span><br><span class="line">        _RCTLogJavaScriptInternal(</span><br><span class="line">          static_cast&lt;RCTLogLevel&gt;(logLevel),</span><br><span class="line">          [<span class="built_in">NSString</span> stringWithUTF8String:message.c_str()]);</span><br><span class="line">      &#125;,</span><br><span class="line">      JSIExecutor::defaultTimeoutInvoker,</span><br><span class="line">      nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调试</span></span><br><span class="line">std::unique_ptr&lt;JSExecutor&gt; RCTObjcExecutorFactory::createJSExecutor(</span><br><span class="line">    std::shared_ptr&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue) &#123;</span><br><span class="line">  <span class="keyword">return</span> std::unique_ptr&lt;JSExecutor&gt;(</span><br><span class="line">    new RCTObjcExecutor(m_jse, m_errorBlock, jsQueue, delegate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MessageQueueThread类型对象用于提供队列执行。这里是由RCTMessageThread来实现，内部用的是CFRunLoop来实现。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueueThread.h</span></span><br><span class="line"><span class="keyword">class</span> MessageQueueThread &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual ~MessageQueueThread() &#123;&#125;</span><br><span class="line">  virtual <span class="keyword">void</span> runOnQueue(std::function&lt;<span class="keyword">void</span>()&gt;&amp;&amp;) = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// runOnQueueSync and quitSynchronous are dangerous.  They should only be</span></span><br><span class="line">  <span class="comment">// used for initialization and cleanup.</span></span><br><span class="line">  virtual <span class="keyword">void</span> runOnQueueSync(std::function&lt;<span class="keyword">void</span>()&gt;&amp;&amp;) = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Once quitSynchronous() returns, no further work should run on the queue.</span></span><br><span class="line">  virtual <span class="keyword">void</span> quitSynchronous() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">_jsMessageThread = std::make_shared&lt;RCTMessageThread&gt;([<span class="built_in">NSRunLoop</span> currentRunLoop], ^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      [weakSelf handleError:error];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>ModuleRegistry，这个包含native module信息的对象，它的来源就是我们上面看到的RCTModuleData。可以看到最终透传参数生成了RCTNativeModule</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">- (std::shared_ptr&lt;ModuleRegistry&gt;)_buildModuleRegistryUnlocked &#123;</span><br><span class="line">  auto registry = std::make_shared&lt;ModuleRegistry&gt;(</span><br><span class="line">         createNativeModules(_moduleDataByID, <span class="keyword">self</span>, _reactInstance),</span><br><span class="line">         moduleNotFoundCallback);</span><br><span class="line">  <span class="keyword">return</span> registry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTCxxUtils.mm</span></span><br><span class="line">std::vector&lt;std::unique_ptr&lt;NativeModule&gt;&gt; createNativeModules(<span class="built_in">NSArray</span>&lt;RCTModuleData *&gt; *modules, RCTBridge *bridge, <span class="keyword">const</span> std::shared_ptr&lt;Instance&gt; &amp;instance)</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;NativeModule&gt;&gt; nativeModules;</span><br><span class="line">  <span class="keyword">for</span> (RCTModuleData *moduleData <span class="keyword">in</span> modules) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([moduleData.moduleClass isSubclassOfClass:[RCTCxxModule <span class="keyword">class</span>]]) &#123;</span><br><span class="line">      <span class="comment">//跨平台，Android用</span></span><br><span class="line">      nativeModules.emplace_back(std::make_unique&lt;CxxNativeModule&gt;(</span><br><span class="line">        instance,</span><br><span class="line">        [moduleData.name UTF8String],</span><br><span class="line">        [moduleData] &#123; <span class="keyword">return</span> [(RCTCxxModule *)(moduleData.instance) createModule]; &#125;,</span><br><span class="line">        std::make_shared&lt;DispatchMessageQueueThread&gt;(moduleData)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nativeModules.emplace_back(std::make_unique&lt;RCTNativeModule&gt;(bridge, moduleData));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nativeModules;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有必要提一下，这上面的moduleData.instance，其实就是生成这个模块对应实例<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithModuleClass:(Class)moduleClass</span><br><span class="line">                             bridge:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithModuleClass:moduleClass</span><br><span class="line">                    moduleProvider:^<span class="keyword">id</span>&lt;RCTBridgeModule&gt;&#123; <span class="keyword">return</span> [moduleClass new]; &#125;</span><br><span class="line">                            bridge:bridge];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时也会准备好它所对应的bridge和method queue<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//RCTModuleData.mm</span></span><br><span class="line"> - (<span class="keyword">void</span>)setBridgeForInstance</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ([_instance respondsToSelector:<span class="keyword">@selector</span>(bridge)] &amp;&amp; _instance.bridge != _bridge) &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">      [(<span class="keyword">id</span>)_instance setValue:_bridge forKey:<span class="string">@"bridge"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUpMethodQueue</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_instance &amp;&amp; !_methodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> implementsMethodQueue = [_instance respondsToSelector:<span class="keyword">@selector</span>(methodQueue)];</span><br><span class="line">    <span class="keyword">if</span> (implementsMethodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">      _methodQueue = _instance.methodQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_methodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">      _queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"com.facebook.react.%@Queue"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">      _methodQueue = dispatch_queue_create(_queueName.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// assign it to the module</span></span><br><span class="line">      <span class="keyword">if</span> (implementsMethodQueue) &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">          [(<span class="keyword">id</span>)_instance setValue:_methodQueue forKey:<span class="string">@"methodQueue"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RCT_PROFILE_END_EVENT(RCTProfileTagAlways, <span class="string">@""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时我们看到Instance::initializeBridge中生成了NativeToJsBridge，到这里Instance的初始化就结束了，下面进入NativeToJsBridge。</p><h3 id="NativeToJsBridge"><a href="#NativeToJsBridge" class="headerlink" title="NativeToJsBridge"></a>NativeToJsBridge</h3><p>NativeToJsBridge作用主要是桥接Native和JS，它包含几个关键属性</p><ul><li><p>&lt;JsToNativeBridge&gt; m_delegate<br>JsToNativeBridge类型的引用，主要用于JS call Native</p></li><li><p>&lt;JSExecutor&gt; m_executor<br> JSExecutor类型引用，主要用于执行Native call JS，这里实际使用是的是JSIExecutor(生产)/RCTObjcExecutor(调试)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;JSExecutorFactory&gt; executorFactory;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.executorClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">RCTCxxBridgeDelegate</span>)]) </span>&#123;</span><br><span class="line">      <span class="keyword">id</span>&lt;RCTCxxBridgeDelegate&gt; cxxDelegate = (<span class="keyword">id</span>&lt;RCTCxxBridgeDelegate&gt;) <span class="keyword">self</span>.delegate;</span><br><span class="line">      executorFactory = [cxxDelegate jsExecutorFactoryForBridge:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!executorFactory) &#123;</span><br><span class="line">      <span class="comment">//生产使用JSCExecutorFactory会生成JSIExecuror</span></span><br><span class="line">      executorFactory = std::make_shared&lt;JSCExecutorFactory&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//调试用RCTObjcExecutorFactory生成RCTObjcExecutor</span></span><br><span class="line">    <span class="keyword">id</span>&lt;RCTJavaScriptExecutor&gt; objcExecutor = [<span class="keyword">self</span> moduleForClass:<span class="keyword">self</span>.executorClass];</span><br><span class="line">    executorFactory.reset(new RCTObjcExecutorFactory(objcExecutor, ^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        [weakSelf handleError:error];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>&lt;MessageQueueThread&gt; m_executorMessageQueueThread<br>MessageQueueThread类型引用，由上层传递，用于队列管理</p></li></ul><h3 id="JSIExecutor"><a href="#JSIExecutor" class="headerlink" title="JSIExecutor"></a>JSIExecutor</h3><p>JSIExecutor主要用来Native call JS，包含几个主要属性：</p><ul><li>&lt;jsi::Runtime&gt; runtime_ <br>Runtime类型指针，代表JS的运行时。这是一个抽象类，其实际上是由JSCRuntime来实现的，JSCRuntime中的功能其实就是通过JavaScriptCode来完成（使用的C函数接口）。JSCRuntime上线了&lt;jsi::Runtime&gt;接口，提供了创建JS上下文的功能，同时可以执行JS。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCRuntime::evaluateJavaScript(</span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">const</span> jsi::Buffer&gt; buffer,</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; sourceURL) &#123;</span><br><span class="line">  std::string tmp(</span><br><span class="line">      reinterpret_cast&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(buffer-&gt;data()), buffer-&gt;size());</span><br><span class="line">  JSStringRef sourceRef = JSStringCreateWithUTF8CString(tmp.c_str());</span><br><span class="line">  JSStringRef sourceURLRef = nullptr;</span><br><span class="line">  <span class="keyword">if</span> (!sourceURL.empty()) &#123;</span><br><span class="line">    sourceURLRef = JSStringCreateWithUTF8CString(sourceURL.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  JSValueRef exc = nullptr;</span><br><span class="line">  JSValueRef res =</span><br><span class="line">      JSEvaluateScript(ctx_, sourceRef, nullptr, sourceURLRef, <span class="number">0</span>, &amp;exc);</span><br><span class="line">  JSStringRelease(sourceRef);</span><br><span class="line">  <span class="keyword">if</span> (sourceURLRef) &#123;</span><br><span class="line">    JSStringRelease(sourceURLRef);</span><br><span class="line">  &#125;</span><br><span class="line">  checkException(res, exc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>&lt;ExecutorDelegate&gt; delegate_<br>ExecutorDelegate类型的指针，这里的ExecutorDelegate是抽象类，实际是由JsToNative来实现的。也即JSIExecutor引用了JsToNative。</p></li><li><p>&lt;JSINativeModules&gt; nativeModules_<br>JSINativeModules由上层传入的ModuleRegistry构造而成，同时会将ModuleRegistry中包含的本地模块配置信息通过”__fbGenNativeModule”保存到JS端。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSINativeModules.cpp</span></span><br><span class="line">folly::Optional&lt;Object&gt; JSINativeModules::createModule(</span><br><span class="line">    Runtime&amp; rt,</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!m_genNativeModuleJS) &#123;</span><br><span class="line">    m_genNativeModuleJS =</span><br><span class="line">        rt.global().getPropertyAsFunction(rt, <span class="string">"__fbGenNativeModule"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  auto result = m_moduleRegistry-&gt;getConfig(name);</span><br><span class="line">  </span><br><span class="line">  Value moduleInfo = m_genNativeModuleJS-&gt;call(</span><br><span class="line">      rt,</span><br><span class="line">      valueFromDynamic(rt, result-&gt;config),</span><br><span class="line">      static_cast&lt;<span class="keyword">double</span>&gt;(result-&gt;index));</span><br><span class="line">  CHECK(!moduleInfo.isNull()) &lt;&lt; <span class="string">"Module returned from genNativeModule is null"</span>;</span><br><span class="line">  <span class="keyword">return</span> module;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NativeModules.js</span></span><br><span class="line">global.__fbGenNativeModule = genModule;</span><br></pre></td></tr></table></figure><p>genModule会根据ModuleRegistry生成的module和method信息生成JS端的方法，结构类似：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: moduleName,</span><br><span class="line">  module: &#123;</span><br><span class="line">    methodName: func</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JSIExecutor执行js方法的实现值得说下。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSIExecutor::callFunction(</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; moduleId,</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; methodId,</span><br><span class="line">    <span class="keyword">const</span> folly::dynamic&amp; arguments) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!callFunctionReturnFlushedQueue_) &#123;</span><br><span class="line">    bindBridge();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto errorProducer = [=] &#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">"moduleID: "</span> &lt;&lt; moduleId &lt;&lt; <span class="string">" methodID: "</span> &lt;&lt; methodId</span><br><span class="line">       &lt;&lt; <span class="string">" arguments: "</span> &lt;&lt; folly::toJson(arguments);</span><br><span class="line">    <span class="keyword">return</span> ss.str();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Value ret = Value::undefined();</span><br><span class="line">  try &#123;</span><br><span class="line">    scopedTimeoutInvoker_(</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">          ret = callFunctionReturnFlushedQueue_-&gt;call(</span><br><span class="line">              *runtime_,</span><br><span class="line">              moduleId,</span><br><span class="line">              methodId,</span><br><span class="line">              valueFromDynamic(*runtime_, arguments));</span><br><span class="line">        &#125;,</span><br><span class="line">        std::move(errorProducer));</span><br><span class="line">  &#125; catch (...) &#123;</span><br><span class="line">    std::throw_with_nested(</span><br><span class="line">        std::runtime_error(<span class="string">"Error calling "</span> + moduleId + <span class="string">"."</span> + methodId));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callNativeModules(ret, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中callFunctionReturnFlushedQueue_来自和JS端的属性绑定<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSIExecutor.cpp</span></span><br><span class="line">Object batchedBridge = batchedBridgeValue.asObject(*runtime_);</span><br><span class="line">callFunctionReturnFlushedQueue_ = batchedBridge.getPropertyAsFunction(</span><br><span class="line">        *runtime_, <span class="string">"callFunctionReturnFlushedQueue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//MessageQueue.js</span></span><br><span class="line">callFunctionReturnFlushedQueue(module: string, method: string, args: any[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.__guard(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.__callFunction(module, method, args);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到callFunctionReturnFlushedQueue_会调用JS端的callFunctionReturnFlushedQueue方法，最终调用在JS端注册好的JS模块和方法。<br>而getPropertyAsFunction则是通过runtime来实现。（runtime是JS和Native沟通的桥梁）</p><h3 id="JsToNativeBridge"><a href="#JsToNativeBridge" class="headerlink" title="JsToNativeBridge"></a>JsToNativeBridge</h3><p>JsToNativeBridge的实现就简单很多，直接通过ModuleRegistry注册好的native信息，调用对应模块的对应方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> callNativeModules(</span><br><span class="line">      JSExecutor&amp; executor, folly::dynamic&amp;&amp; calls, <span class="keyword">bool</span> isEndOfBatch) override &#123;</span><br><span class="line">        </span><br><span class="line">    m_batchHadNativeModuleCalls = m_batchHadNativeModuleCalls || !calls.empty();</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; call : parseMethodCalls(std::move(calls))) &#123;</span><br><span class="line">      m_registry-&gt;callNativeMethod(call.moduleId, call.methodId, std::move(call.arguments), call.callId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEndOfBatch) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m_batchHadNativeModuleCalls) &#123;</span><br><span class="line">        m_callback-&gt;onBatchComplete();</span><br><span class="line">        m_batchHadNativeModuleCalls = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      m_callback-&gt;decrementPendingJSCalls();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中m_registry就是上层传入的ModuleRegistry对象</p><p>那JS Call Native的整套流程是怎样的呢？</p><p> - JS调用MessageQueue.enqueueNativeCall<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enqueueNativeCall(</span><br><span class="line">    moduleID: number,</span><br><span class="line">    methodID: number,</span><br><span class="line">    params: any[],</span><br><span class="line">    onFail: ?Function,</span><br><span class="line">    onSucc: ?Function,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>._queue[MODULE_IDS].push(moduleID);</span><br><span class="line">    <span class="keyword">this</span>._queue[METHOD_IDS].push(methodID);</span><br><span class="line">    <span class="keyword">this</span>._queue[PARAMS].push(params);</span><br><span class="line">    <span class="keyword">const</span> now = Date.now();</span><br><span class="line">    <span class="comment">//MIN_TIME_BETWEEN_FLUSHES_MS = 5</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      global.nativeFlushQueueImmediate &amp;&amp;</span><br><span class="line">      now - <span class="keyword">this</span>._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> queue = <span class="keyword">this</span>._queue;</span><br><span class="line">      <span class="keyword">this</span>._queue = [[], [], [], <span class="keyword">this</span>._callID];</span><br><span class="line">      <span class="keyword">this</span>._lastFlush = now;</span><br><span class="line">      global.nativeFlushQueueImmediate(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到5ms刷新一次</p><ul><li>nativeFlushQueueImmediate对应本地的方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSIExecutor.cpp</span></span><br><span class="line">runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      <span class="string">"nativeFlushQueueImmediate"</span>,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, <span class="string">"nativeFlushQueueImmediate"</span>),</span><br><span class="line">          <span class="number">1</span>,</span><br><span class="line">          [<span class="keyword">this</span>](</span><br><span class="line">              jsi::Runtime&amp;,</span><br><span class="line">              <span class="keyword">const</span> jsi::Value&amp;,</span><br><span class="line">              <span class="keyword">const</span> jsi::Value* args,</span><br><span class="line">              size_t count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">1</span>) &#123;</span><br><span class="line">              throw std::invalid_argument(</span><br><span class="line">                  <span class="string">"nativeFlushQueueImmediate arg count must be 1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            callNativeModules(args[<span class="number">0</span>], <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> Value::undefined();</span><br><span class="line">          &#125;));</span><br></pre></td></tr></table></figure></li></ul><p>可以看到runtime_获取到全局上下文(即JS端的global)，将nativeFlushQueueImmediate属性关联到本地callNativeModules方法。<br>这里值得一提的是，runtime_-&gt;global().setProperty用在很多将JS属性和native方法对象等绑定。</p><ul><li>callNativeModules<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSIExecutor.cpp</span></span><br><span class="line"><span class="keyword">void</span> JSIExecutor::callNativeModules(<span class="keyword">const</span> Value&amp; queue, <span class="keyword">bool</span> isEndOfBatch) &#123;</span><br><span class="line">  delegate_-&gt;callNativeModules(</span><br><span class="line">      *<span class="keyword">this</span>, dynamicFromValue(*runtime_, queue), isEndOfBatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>delegate_就是我们上面提到的&lt;ExecutorDelegate&gt;类型指针，实际就是JsToNativeBridge，最终也就走到了我们上面说的callNativeModules。</p><p>到这里，我们已经具备了native call js和js call native的能力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/assets/uml.jpg" alt="UML图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备-JavaScriptCore&quot;&gt;&lt;a href=&quot;#准备-JavaScriptCore&quot; class=&quot;headerlink&quot; title=&quot;准备-JavaScriptCore&quot;&gt;&lt;/a&gt;准备-JavaScriptCore&lt;/h2&gt;&lt;p&gt;在开篇，我们先简单准备下JavaScriptCore的知识。这是整个Native和JS沟通的最底层的桥梁。&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="www.shanks.pro/categories/ReactNative/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="ReactNative" scheme="www.shanks.pro/tags/ReactNative/"/>
    
      <category term="源码" scheme="www.shanks.pro/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="uml" scheme="www.shanks.pro/tags/uml/"/>
    
  </entry>
  
</feed>
