<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>香克斯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.shanks.pro/"/>
  <updated>2021-06-10T04:12:31.486Z</updated>
  <id>www.shanks.pro/</id>
  
  <author>
    <name>shanks</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS App Launch Optimization</title>
    <link href="www.shanks.pro/2021/06/10/ios_app_launch/"/>
    <id>www.shanks.pro/2021/06/10/ios_app_launch/</id>
    <published>2021-06-10T04:00:00.000Z</published>
    <updated>2021-06-10T04:12:31.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本文首发于携程技术公众号 <a href="https://mp.weixin.qq.com/s/smWjs2X8HWvcvKW_DSXYJA" target="_blank" rel="noopener">干货 | Trip.com APP 启动优化实践</a><br>本文是个人对启动的一点总结，细节不会披露太多，如需了解更多可私信。</p></blockquote><p>App启动是用户对我们 Trip.com App的第一印象，对于用户体验尤为重要，所以我们花了很多时间在启动时间的优化上。<br>下面我们会先分析App启动的过程，在了解启动流程的基础上制定大的优化原则和小的具体方案，希望对大家有所帮助。</p><a id="more"></a><h2 id="App启动的流程分析"><a href="#App启动的流程分析" class="headerlink" title="App启动的流程分析"></a>App启动的流程分析</h2><p>想做启动优化，那就先要了解清楚启动的各个流程，然后才能针对各个环节去做针对性措施。</p><p>借用WWDC对启动阶段的定义图</p><p><img src="/assets/app_launch_cycle.png" alt="App Launch Cycle"></p><h3 id="System-Interface"><a href="#System-Interface" class="headerlink" title="System Interface"></a>System Interface</h3><ul><li>加载App可执行文件</li><li><p>Load dylibs</p><p>  加载动态链接器<code>dyld</code> ，<code>dyld</code>会递归加载App依赖的动态库，然后执行符号绑定<code>Rebase</code>, <code>Bind</code>。一般应用会加载 100 到 400 个 dylib 文件，幸运是大部分是系统库，且系统会在操作系统启动时会计算和缓存系统动态库。</p><p>  Apple为了解决安全问题，引入<code>ASLR</code>和<code>Code Sign</code>，如果不作符号修正，程序将没法正常运行，所以会有Rebase和Bind过程。</p><p>  <img src="/assets/rebase_bind.png" width="200" height="160"></p><ul><li><p>Rebase</p><p>  在镜像内部调整指针的指向，其实就是将内部指针都加上偏移量（Slide=实际新地址-旧地址）</p></li><li><p>Bind</p><p>  修正指外部的指针，比如上图中malloc，这个符号不存在于我们App的Mach-O中，需要从外部的镜像中获取，这时候就需要Bind操作把这个关联起来。</p></li></ul></li><li><p>libSystem init</p><p>   调用系统的的一些初始化方法，这部分一般时间比较固定，可以不用太关注。</p></li></ul><h3 id="Runtime-Init"><a href="#Runtime-Init" class="headerlink" title="Runtime Init"></a>Runtime Init</h3><ul><li><p>Objc和Swift的初始化</p><p>  通过<code>_dyld_objc_notify_register</code>注册回调，在image加载完时初始化语言相关。</p></li><li><p>加载category</p><p>  在上面语言初始化完之后，会加载所有category，处理category的所有方法，协议和属性等。</p></li><li><p>调用所有+load</p><p>  也是通过向dyld 注册回调，在image加载完时，通过<code>load_images</code> 触发，处理该image相关的所有+load方法，按照继承层级依次调用：父类+load→子类+load→category +load，注意category的+load不会覆盖原类。</p></li><li><p>调用C++的构造函数属性函数 <code>attribute((constructor))</code></p></li></ul><h3 id="UIKit-Init"><a href="#UIKit-Init" class="headerlink" title="UIKit Init"></a>UIKit Init</h3><ul><li>实例化 UIApplication 和 UIApplicationDelegate</li><li>开始事件处理和系统集成</li></ul><h3 id="Application-Init"><a href="#Application-Init" class="headerlink" title="Application Init"></a>Application Init</h3><p>这部分是我们熟悉的UIApplicationDelegate的几个生命周期调用：</p><ul><li>application:willFinishLaunchingWithOptions:</li><li>application:didFinishLaunchingWithOptions:</li><li>applicationDidBecomeActive:</li><li>scene:willConnectToSession:options:</li><li>sceneWillEnterForeground:</li><li>sceneDidBecomeActive:</li></ul><h3 id="Initial-Frame-Render"><a href="#Initial-Frame-Render" class="headerlink" title="Initial Frame Render"></a>Initial Frame Render</h3><p>这里是App渲染第一帧，主要做了创建、布局和绘制视图的工作，并把准备好的第一帧提交给渲染层渲染。这里面布局计算，图片解码，图层树的递归commit到Render Server等都是可能影响耗时的点，所以要特别注意。</p><h3 id="Extended"><a href="#Extended" class="headerlink" title="Extended"></a>Extended</h3><p>这里按照苹果的定义，是异步获取数据展示界面的逻辑。比如我们首页要从网络请求数据然后展示最新数据在页面上。</p><h2 id="针对启动的各个流程我们能做什么"><a href="#针对启动的各个流程我们能做什么" class="headerlink" title="针对启动的各个流程我们能做什么"></a>针对启动的各个流程我们能做什么</h2><h3 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h3><p>不管哪个流程，我们都想尽量遵循下面两个原则：</p><ol><li><p>删</p><p> 删的原则是指，对App启动和运行不是必须的任务，或者跟首页渲染第一帧无关的任务，都从启动流程中删除。对于删除的任务，可以进行懒加载的形式，需要时再调用；也可以换到其他的时机去触发，比如首页渲染完之后。</p></li><li><p>压</p><p> 压的原则是指，对App启动和运行必须的任务，或者直接影响首页渲染第一帧的任务，都尽可能压缩其运行时间。至于做法，可以是优化方法内的实现，使其运行更快；也可以将方法执行的线程切换到子线程，以并发的形式降低其对整个启动过程的影响。</p></li></ol><h3 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h3><h4 id="减少动态库"><a href="#减少动态库" class="headerlink" title="减少动态库"></a>减少动态库</h4><p>动态库的加载在启动阶段是必须的，所以我们要尽量减少非必要的动态库。针对这个，我们做了以下几点：</p><ol><li><p>梳理所有动态库，将用不到的或者可以简单替代的动态库删除</p><p> 可以通过<code>otool -L xxx.app/xxx</code> 或者打开打包后的在产物的xxx.app/Frameworks路径中找到所有动态库，逐个筛选，将其中可以废弃和替代的动态库删除。</p></li><li><p>通过推进社区（第三方SDK）将现有动态库转成静态库 </p><p> 因为依赖了第三方SDK，我们是不包含的源码的，所以这部分我们需要推进社区提供静态库的版本，或者通过cocoapods等工具打包SDK的静态库版本。</p></li><li><p>将我们自己的SDK编译成静态库</p><p> 对于我们自己的SDK，因为有源码，所以直接修改<code>MACH_O_TYPE</code> 为<code>Static Library</code> 重新打包即可。</p></li><li><p>App最低支持系统版本升级到12.2</p><p> 因为iOS在12.2版本及以上才内置了Swift的支持，所以在此之前Swift的动态库都是随着App下发的，也在xxx.app/Frameworks 里。</p><p> 当然，这个决策是会直接应用到用户和订单的，所以是要有数据支持的，我们是根据用户占比到达某个阈值才支持12.2的。如果允许，甚至可以升级到iOS 13，因为iOS13以上dlyd3做了很多加载和缓存的优化。</p></li></ol><h4 id="删除无用代码"><a href="#删除无用代码" class="headerlink" title="删除无用代码"></a>删除无用代码</h4><p>如果符号越多，很显然Rebase和Bind的处理时间就会越长，Objc的初始化也受影响，所以我们需要尽可能减少代码：</p><ol><li>通过逆向二进制或者生成linkmap，解析所有方法（<strong>TEXT.</strong>text）和引用到的方法（<strong>DATA </strong>objc_selrefs），找出无用方法删除</li><li>解析所有类（<strong>DATA.</strong>objc_classlist）和引用到的类（<strong>DATA.</strong>objc_classrefs），找出无用的类删除</li><li>使用第三方工具或者clang扫描重复代码，精简去重</li><li>使用<code>LLVM_LTO</code>和<code>GCC_OPTIMIZATION_LEVEL</code>等其他编译选项优化二进制大小</li></ol><h4 id="合并category"><a href="#合并category" class="headerlink" title="合并category"></a>合并category</h4><p>合并category，可以减少category加载时的耗时。不过这部分收益不大，并且也会影响编程习惯，所以我们并没有投入很多时间，不再赘述。</p><h4 id="删除-load"><a href="#删除-load" class="headerlink" title="删除+load"></a>删除+load</h4><p>以前会有很多代码为了省事，加到了+load中，这部分很显然占用启动时间，所以尽量要把这其中的代码转移，可以放到initialize中懒加载，或者放到启动任务中并发执行，这样尽量减少这部分的影响。</p><p>Xcode调试时，可以通过正则添加所有+load方法的断点<code>br s -r &quot;\+\[.+ load\]$&quot;</code> ，然后使用<code>br list</code>打印出所有+load列表，这样方便我们定位所有+load。</p><h4 id="UIApplication子类优化"><a href="#UIApplication子类优化" class="headerlink" title="UIApplication子类优化"></a>UIApplication子类优化</h4><p>为了减少UIKit Init的时间，可以对UIApplication的子类初始化工作优化。我们这部分不存在，所以没有做什么工作。</p><h4 id="启动任务并发"><a href="#启动任务并发" class="headerlink" title="启动任务并发"></a>启动任务并发</h4><p>想象以下，如果<code>application:didFinishLaunchingWithOptions:</code>里面执行的所有启动任务不作任何处理，那么代码框架将会很乱，你的优化也只能单点单点去做。</p><p>所以我们将<code>application:didFinishLaunchingWithOptions:</code>阶段所有方法任务化，一个任务做一种类型的事。任务拆分好之后，就可以根据任务之间的相关性，选择哪些任务是可以并发执行，哪些任务是必须有依赖关系前后执行。</p><p>以前：</p><p><img src="/assets/ios_launch_serial.png" alt=""></p><p>现在：<br><img src="/assets/ios_launch_parrel.png" alt=""></p><p>当然，任务的拆分颗粒度也很重要，拆分太粗的话，很难达到最优的组合，可能一个任务里的方法之间仍然有并行的空间。拆分太细的话，也有可能导致同一时间并发数太多，造成额外的线程切换开销。</p><h4 id="I-O处理"><a href="#I-O处理" class="headerlink" title="I/O处理"></a>I/O处理</h4><p>尤其要注意启动阶段的I/O，一般出现于读取磁盘中的文件，比如配置文件等。</p><p>使用Instrument→App Launch 去查看启动过程就会发现，如果主线程执行出现很多灰色的块，那就是I/O，找到这些I/O产生的方法，尽量在子线程并发执行，避免阻塞主线程。</p><h4 id="首页数据的预加载和懒加载"><a href="#首页数据的预加载和懒加载" class="headerlink" title="首页数据的预加载和懒加载"></a>首页数据的预加载和懒加载</h4><p>首页上有很多数据要加载，比如图片，上次缓存在本地的数据等等，这些数据的加载如果在写代码时不作特殊处理，那会在主线程执行，不知不觉就会有很多耗时</p><ul><li><p>预加载</p><p>  对首页渲染必须的数据，比如一个icon，或者一个翻译的数据，我们通过在启动任务（之前提到的拆分的并发任务）中新增加一个预加载启动任务，专门负责在<code>application:didFinishLaunchingWithOptions:</code>  的过程中并发执行数据的获取。因为获取数据大多比较耗时，所以放在子线程充分利用启动阶段的空闲。同时这类任务大多数是I/O操作，并不会占用太多CPU资源。</p><p>  更进一步，其实可以对首页用到的资源在运行时作个标记，记录到磁盘，下次启动的时候读取这个记录，对用到的资源进行提前预加载，这样避免hard code很多资源名在代码中。</p></li><li><p>懒加载</p><p>  首页的数据往往很多，但并不是一开始要全部用到。可以对数据作区分，和第一屏展示无关的，使用懒加载，真正用到的时候再去加载。</p></li></ul><h4 id="二进制重排"><a href="#二进制重排" class="headerlink" title="二进制重排"></a>二进制重排</h4><ul><li><p><code>page fault</code></p><p>  由于虚拟内存的机制，应用启动时不会把所有数据加载到内存，而是以页为单位逐步从磁盘中加载，内存中的虚拟地址和磁盘中的物理地址有个映射关系。当程序执行时，如果发现要访问的东西不在内存里，就会触发一次<code>page fault</code> ，去磁盘中加载新的一页。</p><p>  启动阶段有很多方法要调用，而这些方法在Mach-O中的的位置又是在编译时确认的。如果有10个方法刚好在不同页，可能就要产生10次<code>page fault</code> 。</p></li></ul><p>二进制重排要做的就是将启动阶段要用到的方法，在编译时提前确定，通过.order文件告诉编译器，这样这些方法会排布在Mach-O的最前面，之前的10次<code>page fault</code> 和可能就变成一两次<code>page fault</code> 。</p><p>通过在Other C Flags中添加<code>-fsanitize-coverage=func,trace-pc-guard</code> 再通过<code>__sanitizer_cov_trace_pc_guard</code>记录启动阶段所有方法的调用，再将这些写入到.order文件中，在Xcode的<code>ORDER_FILE</code> 设置中配置即可生效。</p><p>通过测试，我们的二进制重排大概优化100-200ms。</p><h4 id="其他通用手段"><a href="#其他通用手段" class="headerlink" title="其他通用手段"></a>其他通用手段</h4><p>针对启动任务和首页渲染阶段，通用的手段是通过instrument，profile出耗时长的任务，对任务针对性地作方法优化。如果有的方法是第三方库的，那就需要推进社区去更新。我们在做的过程中就给Firebase和Google的一些SDK提了很多issue，幸运的是对方开发人员配合很积极，对我们帮助很大。</p><h2 id="成果如何"><a href="#成果如何" class="headerlink" title="成果如何"></a>成果如何</h2><p>通过长期的优化，以上手段全部用完之后，我们的启动时间从原来的2秒，优化到1秒以内。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在优化启动时间的过程中，我们的收获不仅是对启动时间的优化，也对系统的启动机制有了更深的了解，同时优化了我们自己的代码，使其变得更加更加健壮和高性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文首发于携程技术公众号 &lt;a href=&quot;https://mp.weixin.qq.com/s/smWjs2X8HWvcvKW_DSXYJA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;干货 | Trip.com APP 启动优化实践&lt;/a&gt;&lt;br&gt;本文是个人对启动的一点总结，细节不会披露太多，如需了解更多可私信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;App启动是用户对我们 Trip.com App的第一印象，对于用户体验尤为重要，所以我们花了很多时间在启动时间的优化上。&lt;br&gt;下面我们会先分析App启动的过程，在了解启动流程的基础上制定大的优化原则和小的具体方案，希望对大家有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.shanks.pro/categories/iOS/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="Launch" scheme="www.shanks.pro/tags/Launch/"/>
    
  </entry>
  
  <entry>
    <title>iOS App Size Optimization</title>
    <link href="www.shanks.pro/2021/03/19/ios-app-size-optimization/"/>
    <id>www.shanks.pro/2021/03/19/ios-app-size-optimization/</id>
    <published>2021-03-19T09:46:00.000Z</published>
    <updated>2021-03-19T12:52:13.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>通过一份Google的数据，下载大小和转换率有关系[<a href="https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2" target="_blank" rel="noopener">参考</a>]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For every <span class="number">6</span> MB increase to an APK’s size, we see a decrease in the install conversion rate of <span class="number">1</span>%.</span><br></pre></td></tr></table></figure><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>要想优化包大小，了解包的构成是前提。对于iOS的App来说，直接下载ipa，解压开就能看到包的构成。</p><ul><li>二进制代码</li><li>资源bundle - 独立bundle管理 .bundle格式</li><li>Frameworks - 动态库，12.2以下可能会包含swift动态库，12.2及以上则只要依赖的动态库</li><li>Plugins - 如果App有Extension等功能，则会有这部分</li><li>翻译 - 可能是在main bundle中，也可能是在独立bundle中，以strings文件呈现</li><li>散落在main bundle的各种其他资源（没有用独立bundle管理）</li></ul><p>通过这里可以看出，按照类型分，包的组成大致是以下几类：</p><ul><li>代码 - 二进制+Pluigns中的代码+Frameworks中的动态库</li><li>资源：图片/json/db/mp3等等资源</li><li>翻译：strings文件（其实可以算资源一种，单独列出来是因为我们的这部分比较大）</li></ul><a id="more"></a><h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><ul><li>删除 - 删除无用</li><li>压缩 - 压缩留在包内的</li><li>转移 - 能远程加载的远程加载</li></ul><p>这里面要考虑很多东西，比如：不是所有的资源都适合远程加载，因为可能会影响用户体验，而用户体验又可能接着影响跳出率/订单转化 等指标，所以把握不准的时候，最好先用数据说话。</p><h1 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h1><p>方案其实就是，将不同类型的包组成（代码/资源/翻译）和不同方案（删除/压缩/转移）的组合，我们一个一个来枚举。</p><p>由于用户只能在AppStore上看到安装大小，所以我们下面讨论的都是基于优化安装大小来说的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="删除代码"><a href="#删除代码" class="headerlink" title="删除代码"></a>删除代码</h3><ul><li><p>通过找出工程中的无用代码来删除</p><p>  对于查找无用代码的方法，个人尝试了以下两种：</p><ol><li><p>反编译或者分析linkmap</p><p> 主要就是找出二进制中描述的所有方法，再结合<code>__DATA.__objc_selrefs</code>段找出所有使用到的方法，两者作差集得到无用的方法（<code>selector</code>）。</p><p> 结合<code>__DATA.__objc_classlist</code>和<code>__DATA.__objc_classrefs</code>作差集找出无用的类。</p></li><li><p>编写编译插件接入编译过程分析</p><p> 通过编写clang的插件，在遍历AST阶段分析代码之间的调用关系。比如在A类中使用<code>performSelector(method)</code> 那么A和method就有了调用关系。将所有的类信息和类的调用信息收集之后，就可以分析出调用了哪些方法，没有调用哪些方法。</p><p>上述两种方法尝试后，各有优缺点：</p><p>方法1分析耗时很短，但是由于OC的语言特性，会有很多误报。方法2因为定制化程度比较高，如果我们有自己定义的router或者运行时方法，可以分析出来，精确度比方法1高，但是要全源码编译，耗时很长很长。</p></li></ol></li><li><p>通过编译配置，让编译器帮我优化代码</p><ol><li>Dead Code Strip - YES</li><li>Strip Link Product - YES</li><li>LTO-incremental（需要在源码编译阶段，而不是在壳工程link阶段配置）</li><li>Optimization Level - Os是既快又小，Oz是aggressive size optimization，对size的优化效果比Os好，同样这个配置也是源码阶段配置</li><li>Deployment Target设置为12.2，这种方式意味着最低版本支持到12.2，需要考虑自己的App用户占比来决定，好处是12.2以上系统内置swift动态库，不会将Swift动态库打进App包内。</li></ol></li><li>其他<ol><li>使用flutter的工程可以考虑做下数据段和代码段剥离</li><li>flutter中的符号信息剥离</li></ol></li></ul><h3 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h3><p>代码不能压缩，此段略去。</p><h3 id="转移代码"><a href="#转移代码" class="headerlink" title="转移代码"></a>转移代码</h3><p>理论上代码是不能远程下发的，但是将native业务改成react native然后远程下发，不失为一种手段。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h3 id="删除资源"><a href="#删除资源" class="headerlink" title="删除资源"></a>删除资源</h3><p>和代码类似，资源的删除是基于找到无用的资源。</p><ul><li><p>native资源</p><p>  因为图片或者其他资源文件的读取方法就那么几个，再考虑到内部封装的方法，所以直接遍历整个工程，找出所有资源文件，再从代码中用正则匹配使用到的资源，很容易能找到无用的资源。</p></li><li><p>flutter资源</p><p>  开启tree shaking icon</p></li></ul><h3 id="压缩资源"><a href="#压缩资源" class="headerlink" title="压缩资源"></a>压缩资源</h3><ul><li>对于图片可以使用tinypng或者ImageOptim等工具进行压缩（一劳永逸：做到打包流程中）</li><li>对于其他资源，都可以进行打包时压缩成7z（7z压缩率比较高），使用时再解压。</li></ul><h3 id="转移资源"><a href="#转移资源" class="headerlink" title="转移资源"></a>转移资源</h3><ul><li>On Demand Resource - 还在实验中，4M的资源下载要花10s左右，如果不是很重要的资源可以尝试</li><li>图片等转远程url，使用时下载</li></ul><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><h3 id="删除翻译"><a href="#删除翻译" class="headerlink" title="删除翻译"></a>删除翻译</h3><p>建立使用率上报机制，定期分析无用的翻译进行删除</p><h3 id="压缩翻译"><a href="#压缩翻译" class="headerlink" title="压缩翻译"></a>压缩翻译</h3><p>因为用的stirngs文件，所以没有考虑过压缩。</p><h3 id="转移资源-1"><a href="#转移资源-1" class="headerlink" title="转移资源"></a>转移资源</h3><p>一个用户不可能用到所有的语种，所以可以按照不同locale的用户占比，将占比低的翻译通过启动时远程下载。</p><p>可能会影响用户体验，所以要配置好保底哪些语言，远程下发哪些语言，及时监测业务指标。</p><h1 id="持续保持"><a href="#持续保持" class="headerlink" title="持续保持"></a>持续保持</h1><p>size的优化肯定不是一次做完就不管的，所以为了长期保持size稳定，我们要建立好长期的管控机制。</p><ul><li><p>分析各个模块size占比</p><p>  通过linkmap分析每个模块大小，再结合对应的资源和翻译，算出每个模块的大小</p></li><li><p>为每个模块设置上限卡点</p><p>  size的保持肯定不是一个人或者一个部门就能做到的，给每个模块设定上限，每次打完模块包分析size数据，当数据超标时会无法参与集成。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>时间有限，没法讲得很详细，以上只能算是趁自己有空做的简单记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;通过一份Google的数据，下载大小和转换率有关系[&lt;a href=&quot;https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;]。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;For every &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; MB increase to an APK’s size, we see a decrease in the install conversion rate of &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;%.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h1&gt;&lt;p&gt;要想优化包大小，了解包的构成是前提。对于iOS的App来说，直接下载ipa，解压开就能看到包的构成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二进制代码&lt;/li&gt;
&lt;li&gt;资源bundle - 独立bundle管理 .bundle格式&lt;/li&gt;
&lt;li&gt;Frameworks - 动态库，12.2以下可能会包含swift动态库，12.2及以上则只要依赖的动态库&lt;/li&gt;
&lt;li&gt;Plugins - 如果App有Extension等功能，则会有这部分&lt;/li&gt;
&lt;li&gt;翻译 - 可能是在main bundle中，也可能是在独立bundle中，以strings文件呈现&lt;/li&gt;
&lt;li&gt;散落在main bundle的各种其他资源（没有用独立bundle管理）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这里可以看出，按照类型分，包的组成大致是以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码 - 二进制+Pluigns中的代码+Frameworks中的动态库&lt;/li&gt;
&lt;li&gt;资源：图片/json/db/mp3等等资源&lt;/li&gt;
&lt;li&gt;翻译：strings文件（其实可以算资源一种，单独列出来是因为我们的这部分比较大）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.shanks.pro/categories/iOS/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="App Size" scheme="www.shanks.pro/tags/App-Size/"/>
    
      <category term="Optimization" scheme="www.shanks.pro/tags/Optimization/"/>
    
  </entry>
  
  <entry>
    <title>Crash学习笔记</title>
    <link href="www.shanks.pro/2020/11/15/ios_crash/"/>
    <id>www.shanks.pro/2020/11/15/ios_crash/</id>
    <published>2020-11-15T09:46:00.000Z</published>
    <updated>2021-03-25T07:59:13.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Crash是什么"><a href="#Crash是什么" class="headerlink" title="Crash是什么"></a>Crash是什么</h2><p>Crash其实就是当有些操作不被系统或者软件允许时，通过一些信号或者异常让进程中止的现象。当然，在收到信号或者异常时，也可以选择不处理让进程继续运行，但是一般不会这样做，因为后可能导致一些不可预知的后果。在OSX&amp;iOS中，Crash一般由以下两种信号产生。</p><a id="more"></a><h3 id="Hardware-Generated-Signals"><a href="#Hardware-Generated-Signals" class="headerlink" title="Hardware-Generated Signals"></a>Hardware-Generated Signals</h3><p>硬件层面的信号（比如常见的野指针）最早是来自处理器的traps，然后会被Mach层捕获，从<code>Mach异常</code>转换为<code>Unix信号</code>，转换逻辑见代码(通用Mach和机器相关异常处理)</p><p><img src="/assets/machtounixsignal.png" alt="Mach Exception to Unix Signal"></p><p>转换为Unix信号之后会统一调用<code>threadsignal</code>最终走到<code>act_set_astbsd</code>()。整个流程如下：</p><p><img src="/assets/hardware_exception_process.png" alt="hardware_exception_process"></p><p>这里有个有趣的地方，就是通过代码我们发现，如果发生<code>stack overflow</code>，那么<code>signal</code>是<code>SIGSEGV</code>而不是<code>SIGBUS</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span> handle_ux_exception(<span class="keyword">thread_t</span>                    thread,</span><br><span class="line">                    <span class="keyword">int</span>                         exception,</span><br><span class="line">                    <span class="keyword">mach_exception_code_t</span>       code,</span><br><span class="line">                    <span class="keyword">mach_exception_subcode_t</span>    subcode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (code == KERN_PROTECTION_FAILURE &amp;&amp;</span><br><span class="line">    ux_signal == SIGBUS) &#123;</span><br><span class="line"><span class="keyword">user_addr_t</span> sp = subcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">user_addr_t</span> stack_max = p-&gt;user_stack;</span><br><span class="line"><span class="keyword">user_addr_t</span> stack_min = p-&gt;user_stack - MAXSSIZ;</span><br><span class="line"><span class="keyword">if</span> (sp &gt;= stack_min &amp;&amp; sp &lt; stack_max) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is indeed a stack overflow.  Deliver a</span></span><br><span class="line"><span class="comment"> * SIGSEGV signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ux_signal = SIGSEGV;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Send signal to thread */</span></span><br><span class="line"><span class="keyword">if</span> (ux_signal != <span class="number">0</span>) &#123;</span><br><span class="line">ut-&gt;uu_exception = exception;</span><br><span class="line"><span class="comment">//ut-&gt;uu_code = code; // filled in by threadsignal</span></span><br><span class="line">ut-&gt;uu_subcode = subcode;</span><br><span class="line">threadsignal(thread, ux_signal, code, TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proc_rele(p);</span><br><span class="line"><span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Software-Generated-Signals"><a href="#Software-Generated-Signals" class="headerlink" title="Software-Generated Signals"></a>Software-Generated Signals</h3><p>除了硬件产生的信号，其他产生的信号（越界，竞态等的软件产生的信号）一般都来自<code>kill</code>(2)或者<code>pthread_kill</code>(2)两个API，最终也会走到act_set_astbsd()。</p><p><img src="/assets/software_exception_process.png" alt="software_exception_process.png"></p><p>为了保持统一的处理机制，系统和用户产生的软件异常，会首先被转换Mach异常然后再转化为Unix信号。</p><h2 id="Crash的捕获"><a href="#Crash的捕获" class="headerlink" title="Crash的捕获"></a>Crash的捕获</h2><p>通过上面的简单分类，我们可能会觉得只要捕获Unix信号可以捕获所有Crash了?其实不是。</p><ol><li><p>如果只捕获Mach异常，不捕获Unix信号，那么遇到<code>EXC_CRASH</code>这种异常就可能出问题。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLCrashReporter</span><br><span class="line"><span class="comment">/* We still need to use signal handlers to catch SIGABRT in-process. The kernel sends an EXC_CRASH mach exception</span></span><br><span class="line"><span class="comment">* in an uninterruptable wait. Thus, we fall back on BSD signal handlers for SIGABRT, and do not register for</span></span><br><span class="line"><span class="comment">* EXC_CRASH. */</span></span><br></pre></td></tr></table></figure></li><li><p>如果只捕获Unix信号，不捕获Mach异常，可能会漏掉一些错误，因为不是所有Mach异常都会转换为Unix信号。</p><p> 这点通过上面的映射表和下面的所有Mach异常定义可以看出来（比如，<code>EXC_GUARD</code>在上表中就没有找到对应的映射Unix Signal）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_BAD_ACCESS1<span class="comment">/* Could not access memory */</span></span></span><br><span class="line"><span class="comment">/* Code contains kern_return_t describing error. */</span></span><br><span class="line"><span class="comment">/* Subcode contains bad memory address. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_BAD_INSTRUCTION2<span class="comment">/* Instruction failed */</span></span></span><br><span class="line"><span class="comment">/* Illegal or undefined instruction or operand */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_ARITHMETIC3<span class="comment">/* Arithmetic exception */</span></span></span><br><span class="line"><span class="comment">/* Exact nature of exception is in code field */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_EMULATION4<span class="comment">/* Emulation instruction */</span></span></span><br><span class="line"><span class="comment">/* Emulation support instruction encountered */</span></span><br><span class="line"><span class="comment">/* Details in code and subcode fields*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_SOFTWARE5<span class="comment">/* Software generated exception */</span></span></span><br><span class="line"><span class="comment">/* Exact exception is in code field. */</span></span><br><span class="line"><span class="comment">/* Codes 0 - 0xFFFF reserved to hardware */</span></span><br><span class="line"><span class="comment">/* Codes 0x10000 - 0x1FFFF reserved for OS emulation (Unix) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_BREAKPOINT6<span class="comment">/* Trace, breakpoint, etc. */</span></span></span><br><span class="line"><span class="comment">/* Details in code field. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_SYSCALL7<span class="comment">/* System calls. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_MACH_SYSCALL8<span class="comment">/* Mach system calls. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_RPC_ALERT9<span class="comment">/* RPC alert */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_CRASH10<span class="comment">/* Abnormal process exit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_RESOURCE11<span class="comment">/* Hit resource consumption limit */</span></span></span><br><span class="line"><span class="comment">/* Exact resource is in code field. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_GUARD12<span class="comment">/* Violated guarded resource protections */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXC_CORPSE_NOTIFY13<span class="comment">/* Abnormal process exited to corpse state */</span></span></span><br></pre></td></tr></table></figure></li></ol><p>所以，正确的捕获Crash方式应该是两种方式同时采用，互相补充。</p><h3 id="KSCrash捕获原理"><a href="#KSCrash捕获原理" class="headerlink" title="KSCrash捕获原理"></a>KSCrash捕获原理</h3><p>我们拿开源的KSCrash来分析，看下针对Crash的捕获需要做些什么。</p><p>KSCrash对Crash的捕获分成了几种类型</p><ul><li>Mach kernel exceptions</li><li>Fatal signals</li><li>C++ exceptions</li><li>Objective-C exceptions</li><li>Main thread deadlock (experimental)</li></ul><p>主线程死锁暂时不看，因为机制完全不一样（通过监听主线程完成类似watchdog的工作）。同时我们注意到除了Mach异常和Unix信号，还单独拆分了C++异常和OC异常（NSException），那是因为C++异常和OC属于上层语言提供的异常，可以被catch和处理，当然也有可能转化为底层信号，但是他们附带的信息会更多，比如NSException抛出时会把原因，用户信息，堆栈等都直接抛出，而捕获底层信号时获取堆栈反而比较麻烦。</p><h4 id="Mach-kernel-exceptions"><a href="#Mach-kernel-exceptions" class="headerlink" title="Mach kernel exceptions"></a>Mach kernel exceptions</h4><p>Mach的异常捕获，依赖Mach层提供的API，从代码流量可看出大致需要做哪些：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">installExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">task_t</span> thisTask = mach_task_self();</span><br><span class="line">    <span class="comment">// 这些类型和我们上面列出来的可以对应上</span></span><br><span class="line">    <span class="keyword">exception_mask_t</span> mask = EXC_MASK_BAD_ACCESS |</span><br><span class="line">    EXC_MASK_BAD_INSTRUCTION |</span><br><span class="line">    EXC_MASK_ARITHMETIC |</span><br><span class="line">    EXC_MASK_SOFTWARE |</span><br><span class="line">    EXC_MASK_BREAKPOINT;</span><br><span class="line">    <span class="keyword">if</span>(g_exceptionPort == MACH_PORT_NULL) &#123;</span><br><span class="line">  <span class="comment">// 新建一个端口接收异常消息，可接收消息</span></span><br><span class="line">        kr = mach_port_allocate(thisTask,</span><br><span class="line">                                MACH_PORT_RIGHT_RECEIVE,</span><br><span class="line">                                &amp;g_exceptionPort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使端口可发送消息</span></span><br><span class="line">        kr = mach_port_insert_right(thisTask,</span><br><span class="line">                                    g_exceptionPort,</span><br><span class="line">                                    g_exceptionPort,</span><br><span class="line">                                    MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 指定g_exceptionPort端口接收异常消息</span></span><br><span class="line">    kr = task_set_exception_ports(thisTask,</span><br><span class="line">                                  mask,</span><br><span class="line">                                  g_exceptionPort,</span><br><span class="line">                                  (<span class="keyword">int</span>)(EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES),</span><br><span class="line">                                  THREAD_STATE_NONE);</span><br><span class="line"><span class="comment">// 创建线程处理异常</span></span><br><span class="line"><span class="comment">// 实际代码中创建了两个线程同时处理，为了代码执行中的死循环</span></span><br><span class="line">    KSLOG_DEBUG(<span class="string">"Creating primary exception thread."</span>);</span><br><span class="line">    error = pthread_create(&amp;g_primaryPThread,</span><br><span class="line">                           &amp;attr,</span><br><span class="line">                           &amp;handleExceptions,</span><br><span class="line">                           kThreadPrimary);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">handleExceptions</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">const</span> userData)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 循环等待g_exceptionPort端口发来的异常消息</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">// Wait for a message.</span></span><br><span class="line">        <span class="keyword">kern_return_t</span> kr = mach_msg(&amp;exceptionMessage.header,</span><br><span class="line">                                    MACH_RCV_MSG,</span><br><span class="line">                                    <span class="number">0</span>,</span><br><span class="line">                                    <span class="keyword">sizeof</span>(exceptionMessage),</span><br><span class="line">                                    g_exceptionPort,</span><br><span class="line">                                    MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                                    MACH_PORT_NULL);</span><br><span class="line">        <span class="keyword">if</span>(kr == KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// 收到异常后退出循环，处理异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(g_isEnabled) &#123;</span><br><span class="line"><span class="comment">//挂起所有除了处理异常线程意外的线程</span></span><br><span class="line">        ksmc_suspendEnvironment(&amp;threads, &amp;numThreads);</span><br><span class="line">        g_isHandlingCrash = <span class="literal">true</span>;</span><br><span class="line">        kscm_notifyFatalExceptionCaptured(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 记录上下文信息，包括所有堆栈和cpu等逆袭</span></span><br><span class="line">        KSMC_NEW_CONTEXT(machineContext);</span><br><span class="line">        KSCrash_MonitorContext* crashContext = &amp;g_monitorContext;</span><br><span class="line">        crashContext-&gt;offendingMachineContext = machineContext;</span><br><span class="line">        kssc_initCursor(&amp;g_stackCursor, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        kscm_handleException(crashContext);</span><br><span class="line">      g_isHandlingCrash = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 恢复现场</span></span><br><span class="line">        ksmc_resumeEnvironment(threads, numThreads);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中处理现场和获取机器堆栈等信息部分太长，有兴趣可以自己查看。总体看下来大致两个步骤：1. 注册一个端口接收异常 2. 新建一个线程监控和处理异常</p><h4 id="Fatal-signals"><a href="#Fatal-signals" class="headerlink" title="Fatal signals"></a>Fatal signals</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">installSignalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span> = &#123;</span>&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    action.sa_flags = SA_SIGINFO | SA_ONSTACK;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> KSCRASH_HOST_APPLE &amp;&amp; defined(__LP64__)</span></span><br><span class="line">    action.sa_flags |= SA_64REGSET;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    sigemptyset(&amp;action.sa_mask);</span><br><span class="line">    action.sa_sigaction = &amp;handleSignal;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fatalSignalsCount; i++) &#123;</span><br><span class="line"><span class="comment">// SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGPIPE,SIGSEGV,SIGSYS,SIGTRAP,</span></span><br><span class="line">        <span class="keyword">if</span>(sigaction(fatalSignals[i], &amp;action, &amp;g_previousSignalHandlers[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// error handle</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSignal</span><span class="params">(<span class="keyword">int</span> sigNum, <span class="keyword">siginfo_t</span>* signalInfo, <span class="keyword">void</span>* userContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_isEnabled) &#123;</span><br><span class="line">        <span class="keyword">thread_act_array_t</span> threads = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">mach_msg_type_number_t</span> numThreads = <span class="number">0</span>;</span><br><span class="line">        ksmc_suspendEnvironment(&amp;threads, &amp;numThreads);</span><br><span class="line">        kscm_notifyFatalExceptionCaptured(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        KSLOG_DEBUG(<span class="string">"Filling out context."</span>);</span><br><span class="line">        KSMC_NEW_CONTEXT(machineContext);</span><br><span class="line">        ksmc_getContextForSignal(userContext, machineContext);</span><br><span class="line">        kssc_initWithMachineContext(&amp;g_stackCursor, KSSC_MAX_STACK_DEPTH, machineContext);</span><br><span class="line"><span class="comment">// 记录信息</span></span><br><span class="line">        kscm_handleException(crashContext);</span><br><span class="line">        ksmc_resumeEnvironment(threads, numThreads);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// This is technically not allowed, but it works in OSX and iOS.</span></span><br><span class="line">    raise(sigNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unix的信号捕获依赖各个类型信号的注册 <code>sigaction</code> ，而其处理过程和之前类似。有意思的是处理完之后，会直接<code>raise</code>，<code>raise</code>的作用是给当前线程发一个信号，不知道为什么注释里写着技术上不允许。</p><h4 id="C-exceptions"><a href="#C-exceptions" class="headerlink" title="C++ exceptions"></a>C++ exceptions</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::set_terminate指定处理</span></span><br><span class="line">g_originalTerminateHandler = <span class="built_in">std</span>::set_terminate(CPPExceptionTerminate);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CPPExceptionTerminate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存现场，挂起线程</span></span><br><span class="line">    ksmc_suspendEnvironment(&amp;threads, &amp;numThreads);</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="literal">NULL</span> || <span class="built_in">strcmp</span>(name, <span class="string">"NSException"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 不处理NSException，避免重复</span></span><br><span class="line">        kscm_notifyFatalExceptionCaptured(<span class="literal">false</span>);</span><br><span class="line">        KSCrash_MonitorContext* crashContext = &amp;g_monitorContext;</span><br><span class="line">        <span class="built_in">memset</span>(crashContext, <span class="number">0</span>, <span class="keyword">sizeof</span>(*crashContext));</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; exc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(descriptionBuff, exc.what(), <span class="keyword">sizeof</span>(descriptionBuff));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录各种信息</span></span><br><span class="line">        KSMC_NEW_CONTEXT(machineContext);</span><br><span class="line">        ksmc_getContextForThread(ksthread_self(), machineContext, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        KSLOG_DEBUG(<span class="string">"Filling out context."</span>);</span><br><span class="line">        crashContext-&gt;crashType = KSCrashMonitorTypeCPPException;</span><br><span class="line">        crashContext-&gt;eventID = g_eventID;</span><br><span class="line">        crashContext-&gt;registersAreValid = <span class="literal">false</span>;</span><br><span class="line">        crashContext-&gt;stackCursor = &amp;g_stackCursor;</span><br><span class="line">        crashContext-&gt;CPPException.name = name;</span><br><span class="line">        crashContext-&gt;exceptionName = name;</span><br><span class="line">        crashContext-&gt;crashReason = description;</span><br><span class="line">        crashContext-&gt;offendingMachineContext = machineContext;</span><br><span class="line">        kscm_handleException(crashContext);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 恢复现场</span></span><br><span class="line">    ksmc_resumeEnvironment(threads, numThreads);</span><br><span class="line"><span class="comment">// 退出</span></span><br><span class="line">    g_originalTerminateHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++的异常主要依靠<code>std::set_terminate</code> ，中间处理的时候用t<code>ry{ throw; } catch {}</code> 来获取异常的信息。</p><h4 id="Objective-C-exceptions"><a href="#Objective-C-exceptions" class="headerlink" title="Objective-C exceptions"></a>Objective-C exceptions</h4><p>OC的异常比较容易，也都很熟悉，使用<code>NSSetUncaughtExceptionHandler</code> 即可，就不贴代码了。</p><h2 id="Crash的符号化"><a href="#Crash的符号化" class="headerlink" title="Crash的符号化"></a>Crash的符号化</h2><p>Crash的符号化前提是，先得有一个符号表<code>dSYM</code> 和crash日志。</p><h3 id="生成dSYM"><a href="#生成dSYM" class="headerlink" title="生成dSYM"></a>生成dSYM</h3><p>Xcode的Build Setting中，需要设置：</p><ol><li>Generate Debug Symbols(<code>GCC_GENERATE_DEBUGGING_SYMBOLS</code>) = YES</li><li>Debug Infomation Format(<code>DEBUG_INFORMATION_FORMAT</code>) = DWARF with dSYM File</li></ol><p>当开启了上述配置，生成的二进制文件中将不再包含符号信息，取而代之的是一个单独的dSYM文件。当发生crash时，crash report里面展示的将是各种对象和方法的内存地址，必须配合dSYM文件才能将真实调用信息解析出来。</p><h3 id="获取Crash-Report"><a href="#获取Crash-Report" class="headerlink" title="获取Crash Report"></a>获取Crash Report</h3><ul><li>TestFlight用户或者允许了发送诊断信息的Appstore用户，可以在Xcode→Window→Organizer→Crash中看到崩溃信息。</li><li>本地测试机器，可以在手机的Setting→Privacy→Analytics &amp; Improvements →Analytics Data→<appbinaryname>_<datetime>找到。</datetime></appbinaryname></li><li>自己捕获Crash然后上报（Bugly, KSCrash, PLCrashReporter…）</li></ul><h3 id="解析Crash-Report"><a href="#解析Crash-Report" class="headerlink" title="解析Crash Report"></a>解析Crash Report</h3><ul><li>如果是在Xcode→Window→Organizer→Crash中看到的Crash，只要把dSYM文件下载到本地机器，可以直接在Organizer中symbolicate</li><li><p>如果是从手机中Analytics Data导出的报告或者自己上报的crash，可以将报告下载下来，按照下面步骤解析。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到命令行工具symbolicatecrash</span></span><br><span class="line">find /Applications/Xcode.app -name symbolicatecrash -type f</span><br><span class="line"><span class="comment">//将symbolicatecrash+dSYM+Crash Report放到一起，假设tmp目录下。</span></span><br><span class="line"><span class="comment">//解析生成crash log</span></span><br><span class="line">./symbolicatecrash ./xxx.ips ./AppName.app.dSYM &gt; crash.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></li><li><p>单行Crash解析</p><p>  Crash Report中除了堆栈调用外，最底下还有镜像的各种信息，拿下面这个举例子，找到想要解析的行，取出想要解析的地址，再找到对应的镜像加载地址和架构。</p><p>  <img src="/assets/single_line_crash_parse.png" alt="single_line_crash_parse.png"></p><p>  拿到这些信息后，可以按照固定格式调用<code>atos</code> </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atos -arch &lt;BinaryArchitecture&gt; -o &lt;PathToDSYMFile&gt;/Contents/Resources/DWARF/&lt;BinaryName&gt;  -l &lt;LoadAddress&gt; &lt;AddressesToSymbolicate&gt;</span><br></pre></td></tr></table></figure><p>  用一个最近的例子说明，我们的crash采集系统有的时候会堆栈解析不出来,大概长这样</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>   IBUWireless                     <span class="number">0x0000000103813788</span> <span class="keyword">void</span>* <span class="built_in">std</span>::__1::__thread_proxy&lt;<span class="built_in">std</span>::__1::tuple&lt;<span class="built_in">std</span>::__1::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::__1::__thread_struct, <span class="built_in">std</span>::__1::default_delete&lt;<span class="built_in">std</span>::__1::__thread_struct&gt; &gt;, <span class="keyword">void</span> (MyThread::*)(), MyThread*&gt; &gt;(<span class="keyword">void</span>*) + <span class="number">12452532</span></span><br></pre></td></tr></table></figure><p>  我尝试用atos解析，还是能正常解析的(XXXXX是打码部分),所以我们的crash采集系统还有待改进。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% atos -arch arm64 -o IBUWireless.app.dSYM/Contents/Resources/DWARF/IBUWireless -l <span class="number">0x101130000</span> <span class="number">0x0000000103813788</span></span><br><span class="line">% __44-[XXXXX updateCell:]_block_invoke (in IBUWireless) (XXXXXX.m:<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Crash的分析"><a href="#Crash的分析" class="headerlink" title="Crash的分析"></a>Crash的分析</h2><p>要分析Crash，先要了解Crash Report的内容组成</p><h3 id="Crash-Report的组成"><a href="#Crash-Report的组成" class="headerlink" title="Crash Report的组成"></a>Crash Report的组成</h3><p><img src="/assets/crash_report_component.png" alt="crash_report_component.png"></p><h4 id="头部信息"><a href="#头部信息" class="headerlink" title="头部信息"></a>头部信息</h4><p>头部信息一般包含以下字段：</p><ul><li><code>Incident Identifier</code>: 唯一标识，不同report不一样。</li><li><code>CrashReporter Key</code>:  唯一设备标识，同一台设备的report这个值是一样的，抹除设备会重制这个值。</li><li><code>Beta Identifier</code>: 只有Testflight有，结合设备和运营商的唯一标识。</li><li><code>Hardware Model</code>: 型号</li><li><code>Process</code>: 进程</li><li><code>Path</code>: 可执行文件的路径</li><li><code>Identifier</code>: BundleID</li><li><code>Version</code>: build号和版本号的结合</li><li><code>AppStoreTools</code>: Xcode版本</li><li><code>AppVariant</code>: app thinning产生的字段</li><li><code>Code Type</code>: CPU结构， <code>ARM-64</code>, <code>ARM</code>, <code>X86-64</code>, or <code>X86</code>.</li><li><code>Parent Process</code>: 父进程ID</li><li><code>Date/Time</code>: 时间信息</li><li><code>Launch Time</code>: 启动时间</li><li><code>OS Version</code>: 系统版本</li></ul><h4 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h4><ul><li><p><code>Exception Type</code>: Mach的异常（Unix信号）</p><p>  <img src="/assets/common_exception_type.png" alt="常见Crash"></p></li><li><p><code>Exception Codes</code>: 处理器特有标识，一般没啥用</p></li><li><code>Exception Subtype</code>: 异常的描述，有些</li><li><code>Exception Message</code>: 额外的描述信息</li><li><code>Termination Reason</code>: 操作系统中止进程时带上的具体原因，常见的case如下</li><li><code>Triggered by Thread</code> or <code>Crashed Thread</code>: 崩溃的线程，大部分情况只看崩溃线程的堆栈就就能定位问题</li></ul><h4 id="诊断信息"><a href="#诊断信息" class="headerlink" title="诊断信息"></a>诊断信息</h4><ul><li><p><code>Application Specific Information</code>: 在 OC和C++ 异常情况下，这里一般有软件层抛出的具体错误信息，能很快定位问题，比如</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[XXXX method]: unrecognized selector sent to instance 0x2834ac5d0'</span><br></pre></td></tr></table></figure></li><li><p><code>Termination Description</code>: 如果是watchdog杀死进程，则可能会有这个字段描述</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Termination Description: SPRINGBOARD, </span><br><span class="line">    scene-create watchdog transgression: application&lt;com.example.MyCoolApp&gt;:<span class="number">667</span></span><br><span class="line">    exhausted real (wall clock) time allowance of 19.97 seconds</span><br></pre></td></tr></table></figure></li><li><p><code>VM Region Info</code>: 内存原因的Crash会带上</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VM Region Info: <span class="number">0</span> is <span class="keyword">not</span> in any region.  Bytes before following region: <span class="number">4307009536</span></span><br><span class="line">      REGION TYPE                      START - END             [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL</span><br><span class="line">      UNUSED SPACE AT START</span><br><span class="line">---&gt;  </span><br><span class="line">      __TEXT                 <span class="number">0000000100b</span>7c000<span class="number">-0000000100b</span>84000 [   <span class="number">32</span>K] r-x/r-x SM=COW  ...pp/MyGreatApp</span><br></pre></td></tr></table></figure></li></ul><h4 id="崩溃堆栈"><a href="#崩溃堆栈" class="headerlink" title="崩溃堆栈"></a>崩溃堆栈</h4><p>大部分情况，我们能通过崩溃堆栈找到错误原因。如果崩溃堆栈是系统线程，我们就需要借助别的手段。</p><h4 id="主线程-其余所有堆栈"><a href="#主线程-其余所有堆栈" class="headerlink" title="主线程+其余所有堆栈"></a>主线程+其余所有堆栈</h4><p>这里记录所有线程的堆栈，当崩溃堆栈不能直接指出原因时，我们可以查看崩溃那一刻，其他所有线程在做什么，寻找每个崩溃时多个线程的共同点，也许会有意外收获。</p><h4 id="崩溃线程状态"><a href="#崩溃线程状态" class="headerlink" title="崩溃线程状态"></a>崩溃线程状态</h4><p>这里记录了崩溃时，线程的状态，包括各个寄存器的值，一般用不到这里。但是一些难以定位的crash可能会借助这个来排查。（我自己也涉及不多-_-）</p><p><img src="/assets/crash_thread_state.png" alt="crash_thread_state.png"></p><h4 id="镜像列表"><a href="#镜像列表" class="headerlink" title="镜像列表"></a>镜像列表</h4><p>这里列举了所有镜像的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式 起始地址-结束地址 名称 架构 uuid 路径</span></span><br><span class="line"><span class="number">0x11eca8000</span> - <span class="number">0x11ecabfff</span>  iAdFramework arm64  &lt;<span class="number">68b</span>5e3f77743340e80ebed9ceaef8837&gt; /System/Library/AccessibilityBundles/iAdFramework.axbundle/iAdFramework</span><br></pre></td></tr></table></figure><p>一般镜像用于解析堆栈，当然也可以用来判断是否越狱，比如如果出现一些典型的比如<code>hookkeyboard.dylib</code> 基本可以判断这台机器是越狱的。</p><h3 id="常见Crash分析"><a href="#常见Crash分析" class="headerlink" title="常见Crash分析"></a>常见Crash分析</h3><p>一般的NSException或者C++异常很好定位，比如空指针，数组越界等，就不赘述。我们单独来看看内存类的Crash，因为这类Crash一般不容易复现和定位。</p><p>内存类错误一般表现为EXC_BAD_ACCESS (SIGSEGV) or EXC_BAD_ACCESS (SIGBUS)，原因是访问了非法内存地址（对象内存已经释放但是指针还在），或者往只读的内存写等。</p><h4 id="使用Xcode分析"><a href="#使用Xcode分析" class="headerlink" title="使用Xcode分析"></a>使用Xcode分析</h4><p>Xcode提供了很多工具分析内存类的错误，<code>Address Sanitize</code> <code>Undefined Behavior Sanitizer Thread Sanitizer</code> 和 静态分析等，都有可能发现App运行中内存问题，如果发现，及时修复。</p><h4 id="Crash-Report分析"><a href="#Crash-Report分析" class="headerlink" title="Crash Report分析"></a>Crash Report分析</h4><p>有的时候通过Xcode提供的工具不一定能完全复现问题，这时候我们要对Crash Report深入分析。</p><ol><li>如果能从崩溃堆栈看出具体代码，能比较快定位。如果堆栈出现<code>objc_msgSend</code>, <code>objc_retain</code>, <code>objc_release</code> ，那这很可能是zombie对象。</li><li><p>内存类错误有的会在Crash Report中的<code>Exception Subtype</code> 指明原因，我们可以通过这个字段进一步定位发生错误的原因。</p><p> <img src="/assets/common_exception_subtype.png" alt="Exception Subtype举例"></p></li><li><p>尝试通过寄存器还原现场</p><p> ARM中，lr存放方法调用的返回地址，通过还原lr中的代码调用，可以看到出错代码的调用入口。</p><p> 拿一个真实的例子来看，通过<code>atos</code>解析lr寄存器存的地址（XXX照样打码），这可能对分析问题会有帮助。</p><p> <img src="/assets/crash_thread_state2.png" alt="crash_thread_state2.png"></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% atos -arch arm64 -o IBUWireless.app.dSYM/Contents/Resources/DWARF/IBUWireless -l <span class="number">0x101130000</span> <span class="number">0x000000010456c89c</span></span><br><span class="line">-[XXXControlView1 topCustomContentView] (in IBUWireless) (XXXControlView1.m:<span class="number">671</span>)</span><br></pre></td></tr></table></figure></li><li><p>通过崩溃用户的所有信息分析共性（操作系统，网络环境，语言，地区…），尝试复现</p></li><li>针对zombie代码，可以试试看实现一个线上的zombie机制，具体可以参考KSCrash中的KSCrashMonitor_Zombie.c的实现，大致原理就是hookNSObject和NSProxy的dealloc方法，当对象dealloc的时候，生成zombie代替原来对象，这样当下次再有该对象的dealloc消息过来，就可以判定为重复释放。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，本次学习了Crash的生成，捕获，符号化和分析，但是真实的Crash还是有很多细节在里面，需要自己在实践中一步步感受。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>《Mac OS and iOS Internals》</p><p><a href="https://developer.apple.com/documentation/xcode/diagnosing_issues_using_crash_reports_and_device_logs" target="_blank" rel="noopener">Diagnosing Issues Using Crash Reports and Device Logs</a></p><p><a href="https://wemp.app/posts/dfd8e1a6-a609-4299-94a0-b01fc70520ec" target="_blank" rel="noopener">Crash分析攻略</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Crash是什么&quot;&gt;&lt;a href=&quot;#Crash是什么&quot; class=&quot;headerlink&quot; title=&quot;Crash是什么&quot;&gt;&lt;/a&gt;Crash是什么&lt;/h2&gt;&lt;p&gt;Crash其实就是当有些操作不被系统或者软件允许时，通过一些信号或者异常让进程中止的现象。当然，在收到信号或者异常时，也可以选择不处理让进程继续运行，但是一般不会这样做，因为后可能导致一些不可预知的后果。在OSX&amp;amp;iOS中，Crash一般由以下两种信号产生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.shanks.pro/categories/iOS/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="Crash" scheme="www.shanks.pro/tags/Crash/"/>
    
  </entry>
  
  <entry>
    <title>LLVM-Driver笔记</title>
    <link href="www.shanks.pro/2020/07/14/llvm-driver/"/>
    <id>www.shanks.pro/2020/07/14/llvm-driver/</id>
    <published>2020-07-14T09:46:00.000Z</published>
    <updated>2020-07-14T10:00:02.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Driver"><a href="#什么是Driver" class="headerlink" title="什么是Driver"></a>什么是Driver</h1><p>在单独编译文件时，我们经常会使用到如下的一些命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -ccc-print-phases main.m</span><br></pre></td></tr></table></figure><p>这里我们使用的’clang’其实不是我们通常所说的llvm的编译前端clang，而是一个命令行工具，指的就是Clang Driver，它是一个驱动，是面向用户提供接口，内部解析参数，调用编译的中的工具完成编译的过程。</p><a id="more"></a><h1 id="Driver怎么设计"><a href="#Driver怎么设计" class="headerlink" title="Driver怎么设计"></a>Driver怎么设计</h1><p>关于这点，clang官方文档有介绍，我这里做个总结</p><p><a href="https://clang.llvm.org/docs/DriverInternals.html" target="_blank" rel="noopener">Clang 11 documentation</a></p><h2 id="特点和目标"><a href="#特点和目标" class="headerlink" title="特点和目标"></a>特点和目标</h2><ol><li><p>与GCC的兼容性</p><p> 官方的解释是与GCC的兼容可以让用户在他们的工程中快速使用clang，我理解隐含的意思是为了和GCC抢占用户，这是必须的。</p></li><li><p>灵活性</p><p> 这个很好理解，和写代码一样，随着clang和LLVM的发展，足够的灵活性保证了新功能的扩展。</p></li><li><p>开销小</p><p> 和编译工作相比，Driver的工作量并不大，但是也要遵循一些基本的规则来保持它的高效。</p><ul><li>尽可能避免内存分配和字符串拷贝</li><li>不要多次解析参数</li><li>提供一些简单的接口来有效地搜索参数</li></ul></li><li><p>简单</p><p> 尽管为了兼容GCC给Driver带来了很多复杂的逻辑，但是整个Driver的设计还是尽可能简单。为了达到这个目的，将Driver分为多个独立的阶段而不是一个大的任务。</p></li></ol><h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><p><img src="/assets/llvm_driver_architecture.png" alt="DriverArchitecture"></p><p> 这是一张来自官网的图，介绍了Driver内部设计的几个阶段。其中，橙色的代表数据，绿色代表操作这些数据的阶段，蓝色的代表辅助组件。</p><ol><li><p>Input Strings</p><p> 这条不用多解释，就是我们调用clang的时候后面传入的标示和数据</p></li><li><p>Parse: Option Parsing</p><p> 这一步就是将我们传入的String类型输入，解析成具体的参数对象，方便后面使用和传递。关于这点，和其他一些命令行工具其实是差不多的，比如<a href="https://github.com/google/python-fire" target="_blank" rel="noopener">python-fire</a> 和 <a href="https://github.com/CocoaPods/CLAide" target="_blank" rel="noopener">CLAide</a>。具体解析细节我们后面再介绍，如果像看大概的解析过程，使用<code>-###</code> 就可以。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ clang -<span class="comment">### -Xarch_i386 -fomit-frame-pointer -Wa,-fast -Ifoo -I foo t.c</span></span><br><span class="line"></span><br><span class="line">Option 0 - Name: <span class="string">"-Xarch_"</span>, Values: &#123;<span class="string">"i386"</span>, <span class="string">"-fomit-frame-pointer"</span>&#125;</span><br><span class="line">Option 1 - Name: <span class="string">"-Wa,"</span>, Values: &#123;<span class="string">"-fast"</span>&#125;</span><br><span class="line">Option 2 - Name: <span class="string">"-I"</span>, Values: &#123;<span class="string">"foo"</span>&#125;</span><br><span class="line">Option 3 - Name: <span class="string">"-I"</span>, Values: &#123;<span class="string">"foo"</span>&#125;</span><br><span class="line">Option 4 - Name: <span class="string">"&lt;input&gt;"</span>, Values: &#123;<span class="string">"t.c"</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>Pipeline: Compilation Action Construction</p><p> 一旦解析了参数，就会构造出后续编译所需要的子任务。这涉及到确定输入文件及其类型，要对它们做哪些工作（预处理、编译、组装、链接等），以及为每个任务构造一个Action实例列表。其结果是一个由一个或多个顶层Action组成的列表，每个Action通常对应一个单一的输出（例如，一个对象或链接的可执行文件）。</p><p> 使用<code>-ccc-print-phases</code> 可以打印出这个阶段的内容：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ clang -ccc-print-phases -x c t.c -x assembler t.s</span><br><span class="line">0: input, <span class="string">"t.c"</span>, c</span><br><span class="line">1: preprocessor, &#123;0&#125;, cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, assembler</span><br><span class="line">3: assembler, &#123;2&#125;, object</span><br><span class="line">4: input, <span class="string">"t.s"</span>, assembler</span><br><span class="line">5: assembler, &#123;4&#125;, object</span><br><span class="line">6: linker, &#123;3, 5&#125;, image</span><br></pre></td></tr></table></figure><p> 当这个阶段完成之后，编译过程将会以被分成多个小的Action，每个Action的阶段就是我们熟知的”预处理→编译→汇编→连接”等。</p></li><li><p>Bind: Tool &amp; Filename Selection</p><p> 这个阶段和后面的Trasnlate一起将将Actions转化成真正的进程。Driver自上而下匹配，将Actioins分配给分配给Tools，ToolChain负责为每个Action选择合适的Tool，一旦选择了Tool，Driver就会与Tool交互，看它是否能够匹配更多的Action。</p><p> 一旦所有的Action都选择了Tool，Driver就会决定如何连接工具（例如，使用进程内模块、管道、临时文件或用户提供的文件名）。</p><p> Driver驱动程序与ToolChain交互，以执行Tool的绑定。ToolChain包含了特定架构、平台和操作系统编译所需的所有工具的信息，一次编译过程中，单个Driver调用可能会查询多个ToolChain，以便与不同架构的工具进行交互。</p><p> 可以通过<code>-ccc-print-bindings</code> 可以查看Bind的大致情况，以下展示了在i386和ppc上编译t0.c文件Bing过程。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ clang -ccc-print-bindings -arch i386 -arch ppc t0.c</span><br><span class="line"><span class="comment"># "i386-apple-darwin9" - "clang", inputs: ["t0.c"], output: "/tmp/cc-Sn4RKF.s"</span></span><br><span class="line"><span class="comment"># "i386-apple-darwin9" - "darwin::Assemble", inputs: ["/tmp/cc-Sn4RKF.s"], output: "/tmp/cc-gvSnbS.o"</span></span><br><span class="line"><span class="comment"># "i386-apple-darwin9" - "darwin::Link", inputs: ["/tmp/cc-gvSnbS.o"], output: "/tmp/cc-jgHQxi.out"</span></span><br><span class="line"><span class="comment"># "ppc-apple-darwin9" - "gcc::Compile", inputs: ["t0.c"], output: "/tmp/cc-Q0bTox.s"</span></span><br><span class="line"><span class="comment"># "ppc-apple-darwin9" - "gcc::Assemble", inputs: ["/tmp/cc-Q0bTox.s"], output: "/tmp/cc-WCdicw.o"</span></span><br><span class="line"><span class="comment"># "ppc-apple-darwin9" - "gcc::Link", inputs: ["/tmp/cc-WCdicw.o"], output: "/tmp/cc-HHBEBh.out"</span></span><br><span class="line"><span class="comment"># "i386-apple-darwin9" - "darwin::Lipo", inputs: ["/tmp/cc-jgHQxi.out", "/tmp/cc-HHBEBh.out"], output: "a.out"</span></span><br></pre></td></tr></table></figure></li><li><p>Translate: Tool Specific Argument Translation</p><p> 一旦选择了一个Tool来执行一个特定的Action，该Tool必须构建具体的Commands，并在编译过程中执行。该阶段主要的工作是将gcc风格的命令行选项翻译成子进程所期望的任何选项。</p><p> 这个阶段的结果是一些列将要执行Commands（包含执行路径和参数字符）。</p></li><li><p>Execute</p><p> 执行阶段，之前上一阶段输出的命令，并且产出结果。</p></li></ol><hr><p>以上关于Driver的设计都可以在LLVM的官网能找到，可能很多介绍比较抽象，下面我介绍下更多的代码相关的细节。</p><h1 id="Driver的代码分析"><a href="#Driver的代码分析" class="headerlink" title="Driver的代码分析"></a>Driver的代码分析</h1><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>在<code>clang/tools/driver/driver.cpp</code> 我们可以找到Driver的入口，其中入口逻辑都集中在main之中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc_, <span class="keyword">const</span> <span class="keyword">char</span> **argv_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化LLVM</span></span><br><span class="line">  <span class="comment">// 1. 设置信号handler，当进程崩溃是可以打印堆栈 2. 处理windows上的参数编码，保证参数传递进去的是utf-8</span></span><br><span class="line">  llvm::<span class="function">InitLLVM <span class="title">X</span><span class="params">(argc_, argv_)</span></span>;</span><br><span class="line">  SmallVector&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="number">256</span>&gt; argv(argv_, argv_ + argc_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保证标准文件描述符(input, output, error)的正确映射</span></span><br><span class="line">  <span class="keyword">if</span> (llvm::sys::Process::FixupStandardFileDescriptors())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 初始化LLVM支持的所有目标机器，比如arm，x86等</span></span><br><span class="line">  llvm::InitializeAllTargets();</span><br><span class="line">  <span class="comment">// 根据传入参数，解析出需要的:</span></span><br><span class="line">  <span class="comment">// TargetPrefix： i686-linux-android</span></span><br><span class="line">  <span class="comment">// ModeSuffix： g++，gcc，cpp等</span></span><br><span class="line">  <span class="comment">// DriverMode：--driver-mode=g++ 或者--driver-mode=gcc等</span></span><br><span class="line">  <span class="keyword">auto</span> TargetAndMode = ToolChain::getTargetAndModeFromProgramName(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Driver <span class="title">TheDriver</span><span class="params">(Path, llvm::sys::getDefaultTargetTriple(), Diags)</span></span>;</span><br><span class="line">  <span class="comment">// 设置clang所在目录</span></span><br><span class="line">  SetInstallDir(argv, TheDriver, CanonicalPrefixes);</span><br><span class="line">  <span class="comment">// 用之前的targe和mode赋值</span></span><br><span class="line">  TheDriver.setTargetAndMode(TargetAndMode);</span><br><span class="line">  <span class="comment">// 将target和mode信息插入到argv中</span></span><br><span class="line">  insertTargetAndModeArgs(TargetAndMode, argv, SavedStrings);</span><br><span class="line">  <span class="comment">// 设置默认的CC_PRINT_OPTIONS/CC_PRINT_HEADERS/CC_LOG_DIAGNOSTICS输出文件，会在环境变量中指定</span></span><br><span class="line">  SetBackdoorDriverOutputsFromEnvVars(TheDriver);</span><br><span class="line">  <span class="comment">// 返回Compilation对象，包含一个driver调用的一系列任务</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Compilation&gt; C(TheDriver.BuildCompilation(argv));</span><br><span class="line">  <span class="keyword">int</span> Res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (C &amp;&amp; !C-&gt;containsError()) &#123;</span><br><span class="line">    SmallVector&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">const</span> Command *&gt;, <span class="number">4</span>&gt; FailingCommands;</span><br><span class="line">    <span class="comment">// 根据参数列表执行编译动作并且返回正确的返回码</span></span><br><span class="line">    Res = TheDriver.ExecuteCompilation(*C, FailingCommands);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>driver.cpp</code> 中大致做了几件事情：</p><ol><li>做些环境的检测和各自对象数据的准备</li><li>解析参数中target，mode信息</li><li>初始化<code>Driver</code>对象，并对其赋值target，mode等等需要的数据</li><li>通过<code>Driver</code>对象生成<code>Compilation</code>对象并且执行编译命令</li></ol><h2 id="BuildCompilation-amp-ExecuteCompilation"><a href="#BuildCompilation-amp-ExecuteCompilation" class="headerlink" title="BuildCompilation&amp;ExecuteCompilation"></a>BuildCompilation&amp;ExecuteCompilation</h2><p>上面<code>driver.cpp</code> 中很重要的一步是<code>BuildCompilation</code>，这一步做了很多事情，我们看下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Compilation *Driver::BuildCompilation(ArrayRef&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; ArgList) &#123;</span><br><span class="line">  <span class="comment">//省略..</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Parse参数</span></span><br><span class="line">  <span class="keyword">bool</span> ContainsError;</span><br><span class="line">  CLOptions = llvm::make_unique&lt;InputArgList&gt;(</span><br><span class="line">      ParseArgStrings(ArgList.slice(<span class="number">1</span>), IsCLMode(), ContainsError));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有来自文件的配置，从文件中加载配置参数</span></span><br><span class="line">  <span class="comment">// 会解析来自command line指定的.cfg或者在用户+系统指定的Search Path中找</span></span><br><span class="line">  <span class="keyword">if</span> (!ContainsError)</span><br><span class="line">    ContainsError = loadConfigFile();</span><br><span class="line">  <span class="keyword">bool</span> HasConfigFile = !ContainsError &amp;&amp; (CfgOptions.get() != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并来自commnad line的参数和来自配置文件的配置</span></span><br><span class="line">  InputArgList Args = <span class="built_in">std</span>::move(HasConfigFile ? <span class="built_in">std</span>::move(*CfgOptions)</span><br><span class="line">                                              : <span class="built_in">std</span>::move(*CLOptions));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略合并过程，最终合并得到Args</span></span><br><span class="line">  <span class="comment">// 省略各种参数赋值和处理...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;llvm::opt::InputArgList&gt; UArgs =</span><br><span class="line">      llvm::make_unique&lt;InputArgList&gt;(<span class="built_in">std</span>::move(Args));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Translate</span></span><br><span class="line">  DerivedArgList *TranslatedArgs = TranslateInputArgs(*UArgs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造ToolChain</span></span><br><span class="line">  <span class="keyword">const</span> ToolChain &amp;TC = getToolChain(</span><br><span class="line">      *UArgs, computeTargetTriple(*<span class="keyword">this</span>, TargetTriple, *UArgs));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将trasnlate结束的参数传递给Compilation</span></span><br><span class="line">  Compilation *C = <span class="keyword">new</span> Compilation(*<span class="keyword">this</span>, TC, UArgs.release(), TranslatedArgs,</span><br><span class="line">                                   ContainsError);</span><br><span class="line">  <span class="comment">// 处理一些立即处理和退出的命令，比如-help，-version这种</span></span><br><span class="line">  <span class="keyword">if</span> (!HandleImmediateArgs(*C))</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct the list of inputs.</span></span><br><span class="line">  InputList Inputs;</span><br><span class="line">  BuildInputs(C-&gt;getDefaultToolChain(), *TranslatedArgs, Inputs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Populate the tool chains for the offloading devices, if any.</span></span><br><span class="line">  CreateOffloadingDeviceToolChains(*C, Inputs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造Actions</span></span><br><span class="line">  <span class="keyword">if</span> (TC.getTriple().isOSBinFormatMachO())</span><br><span class="line">    BuildUniversalActions(*C, C-&gt;getDefaultToolChain(), Inputs);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    BuildActions(*C, C-&gt;getArgs(), Inputs, C-&gt;getActions());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 来自ccc-print-phases </span></span><br><span class="line">  <span class="keyword">if</span> (CCCPrintPhases) &#123;</span><br><span class="line">    PrintActions(*C);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造Jobs</span></span><br><span class="line">  BuildJobs(*C);</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过省略干扰我们理解的其他代码，可以发现，<code>BuildCompilation</code>主要做了以下几件事情：</p><ol><li>解析参数</li><li>翻译参数</li><li>构造Actions和Jobs</li></ol><p>基本和官方设计所提到的几个流程能对应上，同时我们也能看到之前提到的<code>ccc-print-phases</code> 是在这里处理Actions的打印。</p><p>而<code>ExecuteCompilation</code>的则比较简单，就是我们之前设计图中最后的执行步骤。同时也能看到为什么我们输入<code>-###</code> 能够打印出Jobs的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Driver::ExecuteCompilation(</span><br><span class="line">    Compilation &amp;C,</span><br><span class="line">    SmallVectorImpl&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">const</span> Command *&gt;&gt; &amp;FailingCommands) &#123;</span><br><span class="line">  <span class="comment">// 处理-###的参数</span></span><br><span class="line">  <span class="keyword">if</span> (C.getArgs().hasArg(options::OPT__HASH_HASH_HASH)) &#123;</span><br><span class="line">    C.getJobs().Print(llvm::errs(), <span class="string">"\n"</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  C.ExecuteJobs(C.getJobs(), FailingCommands);</span><br><span class="line">  <span class="comment">// 省略...处理失败已经打印一些额外的数据</span></span><br><span class="line">  <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h2><p>我们根据上面<code>BuildCompilation</code> 中的步骤，来看看Parse这一步是怎么实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">InputArgList Driver::ParseArgStrings(ArrayRef&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; ArgStrings,</span><br><span class="line">                                     <span class="keyword">bool</span> IsClCompatMode,</span><br><span class="line">                                     <span class="keyword">bool</span> &amp;ContainsError) &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  InputArgList Args =</span><br><span class="line">      getOpts().ParseArgs(ArgStrings, MissingArgIndex, MissingArgCount,</span><br><span class="line">                          IncludedFlagsBitmask, ExcludedFlagsBitmask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略各种校验和错误处理等...</span></span><br><span class="line">  <span class="keyword">return</span> Args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputArgList OptTable::ParseArgs(ArrayRef&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; ArgArr,</span><br><span class="line">                                 <span class="keyword">unsigned</span> &amp;MissingArgIndex,</span><br><span class="line">                                 <span class="keyword">unsigned</span> &amp;MissingArgCount,</span><br><span class="line">                                 <span class="keyword">unsigned</span> FlagsToInclude,</span><br><span class="line">                                 <span class="keyword">unsigned</span> FlagsToExclude) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="function">InputArgList <span class="title">Args</span><span class="params">(ArgArr.begin(), ArgArr.end())</span></span>;</span><br><span class="line"></span><br><span class="line">  MissingArgIndex = MissingArgCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> Index = <span class="number">0</span>, End = ArgArr.size();</span><br><span class="line">  <span class="keyword">while</span> (Index &lt; End) &#123;</span><br><span class="line">    <span class="comment">// 省略nullptr和空字符串等处理...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> Prev = Index;</span><br><span class="line">    Arg *A = ParseOneArg(Args, Index, FlagsToInclude, FlagsToExclude);</span><br><span class="line">    assert(Index &gt; Prev &amp;&amp; <span class="string">"Parser failed to consume argument."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略错误校验...</span></span><br><span class="line"></span><br><span class="line">    Args.append(A);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arg *OptTable::ParseOneArg(<span class="keyword">const</span> ArgList &amp;Args, <span class="keyword">unsigned</span> &amp;Index,</span><br><span class="line">                           <span class="keyword">unsigned</span> FlagsToInclude,</span><br><span class="line">                           <span class="keyword">unsigned</span> FlagsToExclude) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> Prev = Index;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *Str = Args.getArgString(Index);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Info *Start = OptionInfos.data() + FirstSearchableIndex;</span><br><span class="line">  <span class="keyword">const</span> Info *End = OptionInfos.data() + OptionInfos.size();</span><br><span class="line">  StringRef Name = StringRef(Str).ltrim(PrefixChars);</span><br><span class="line"></span><br><span class="line">  Start = <span class="built_in">std</span>::lower_bound(Start, End, Name.data());</span><br><span class="line">  <span class="keyword">for</span> (; Start != End; ++Start) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> ArgSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="function">Option <span class="title">Opt</span><span class="params">(Start, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="keyword">if</span> (Arg *A = Opt.accept(Args, Index, ArgSize))</span><br><span class="line">      <span class="keyword">return</span> A;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保底</span></span><br><span class="line">  <span class="keyword">if</span> (Str[<span class="number">0</span>] == <span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Arg(getOption(TheInputOptionID), Str, Index++, Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Arg(getOption(TheUnknownOptionID), Str, Index++, Str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有些代码只是简单封装，主要流程就是从参数String中逐个解析生成<code>Arg</code> 对象，最后组成<code>InputArgList</code> 。<code>Opt.accept</code> 逻辑我们在这里就不说了，其实就是根据不同类型的参数解析然后返回，我们重点说下<code>Option</code> ，因为<code>Opt.accept</code> 处理的核心需要依赖<code>Option</code> 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Option(<span class="keyword">const</span> OptTable::Info *Info, <span class="keyword">const</span> OptTable *Owner);</span><br></pre></td></tr></table></figure><p><code>Option</code>的生成需要<code>OptTable::Info</code>和<code>OptTable</code>两个参数，通过跟踪代码，我们可以在<code>Driver</code>的构造函数中找到<code>OptTable</code>的生成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;OptTable&gt; clang::driver::createDriverOptTable() &#123;</span><br><span class="line">  <span class="keyword">auto</span> Result = llvm::make_unique&lt;DriverOptTable&gt;();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(Result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DriverOptTable</span> :</span> <span class="keyword">public</span> OptTable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  DriverOptTable()</span><br><span class="line">    : OptTable(InfoTable) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> OptTable::Info InfoTable[] = &#123;</span><br><span class="line">#define OPTION(PREFIX, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,  \</span><br><span class="line">               HELPTEXT, METAVAR, VALUES)                                      \</span><br><span class="line">  &#123;PREFIX, NAME,  HELPTEXT,    METAVAR,     OPT_##ID,  Option::KIND##Class,    \</span><br><span class="line">   PARAM,  FLAGS, OPT_##GROUP, OPT_##ALIAS, ALIASARGS, VALUES&#125;,</span><br><span class="line">#include <span class="string">"clang/Driver/Options.inc"</span></span><br><span class="line">#undef OPTION</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，<code>OptTable</code>的生成是依靠预先定义好的<code>InfoTable[]</code> 来生成的。这里以宏的形式定了一个Option应该包含哪些属性，同时引入了<code>Options.inc</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OPTION</span></span><br><span class="line">OPTION(prefix_1, <span class="string">"###"</span>, _HASH_HASH_HASH, Flag, INVALID, INVALID, <span class="literal">nullptr</span>, DriverOption | CoreOption, <span class="number">0</span>,</span><br><span class="line">       <span class="string">"Print (but do not run) the commands to run for this compilation"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)</span><br><span class="line">OPTION(prefix_1, <span class="string">"ast-dump"</span>, ast_dump, Flag, Action_Group, INVALID, <span class="literal">nullptr</span>, CC1Option | NoDriverOption, <span class="number">0</span>,</span><br><span class="line">       <span class="string">"Build ASTs and then debug dump them"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)</span><br><span class="line">OPTION(prefix_1, <span class="string">"ccc-print-phases"</span>, ccc_print_phases, Flag, internal_debug_Group, INVALID, <span class="literal">nullptr</span>, DriverOption | HelpHidden | CoreOption, <span class="number">0</span>,</span><br><span class="line">       <span class="string">"Dump list of actions to perform"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// OPTION</span></span></span><br></pre></td></tr></table></figure><p>我这里截取了几个定义，都是我们比较熟悉和常见的，我们支持的每个命令都能在这里找到定义。</p><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>因为<code>BuildUniversalActions</code>最终会调用<code>BuildActions</code>，所以我们来看看<code>BuildActions</code>的处理逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Driver::BuildActions(Compilation &amp;C, DerivedArgList &amp;Args,</span><br><span class="line">                          <span class="keyword">const</span> InputList &amp;Inputs, ActionList &amp;Actions) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到Final Phase</span></span><br><span class="line">  Arg *FinalPhaseArg;</span><br><span class="line">  phases::ID FinalPhase = getFinalPhase(Args, &amp;FinalPhaseArg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略根据FinalPhase等信息构造Actions...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">phases::ID Driver::getFinalPhase(<span class="keyword">const</span> DerivedArgList &amp;DAL,</span><br><span class="line">                                 Arg **FinalPhaseArg) <span class="keyword">const</span> &#123;</span><br><span class="line">  Arg *PhaseArg = <span class="literal">nullptr</span>;</span><br><span class="line">  phases::ID FinalPhase;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -&#123;E,EP,P,M,MM&#125; only run the preprocessor.</span></span><br><span class="line">  <span class="keyword">if</span> (CCCIsCPP() || (PhaseArg = DAL.getLastArg(options::OPT_E)) ||</span><br><span class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_EP)) ||</span><br><span class="line">      (PhaseArg = DAL.getLastArg(options::OPT_M, options::OPT_MM)) ||</span><br><span class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_P))) &#123;</span><br><span class="line">    FinalPhase = phases::Preprocess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --precompile only runs up to precompilation.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT__precompile))) &#123;</span><br><span class="line">    FinalPhase = phases::Precompile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -&#123;fsyntax-only,-analyze,emit-ast&#125; only run up to the compiler.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_fsyntax_only)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_module_file_info)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_verify_pch)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_objc)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_legacy_objc)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT__migrate)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT__analyze,</span><br><span class="line">                                        options::OPT__analyze_auto)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_emit_ast))) &#123;</span><br><span class="line">    FinalPhase = phases::Compile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -S only runs up to the backend.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_S))) &#123;</span><br><span class="line">    FinalPhase = phases::Backend;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -c compilation only runs up to the assembler.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_c))) &#123;</span><br><span class="line">    FinalPhase = phases::Assemble;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Otherwise do everything.</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    FinalPhase = phases::Link;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FinalPhaseArg)</span><br><span class="line">    *FinalPhaseArg = PhaseArg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FinalPhase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，不同的参数决定了我们这一次过程的最后阶段不一样，比如如果我们参数列表里带了<code>-fsyntax-only</code> ，那我们最后久之后走到编译这一步，后面的汇编，链接等阶段是不会涉及的。</p><h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>在执行编译的过程中，Bind会为不同的Action选定不同的Tool。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">InputInfo Driver::BuildJobsForActionNoCache(</span><br><span class="line">    Compilation &amp;C, <span class="keyword">const</span> Action *A, <span class="keyword">const</span> ToolChain *TC, StringRef BoundArch,</span><br><span class="line">    <span class="keyword">bool</span> AtTopLevel, <span class="keyword">bool</span> MultipleArchs, <span class="keyword">const</span> <span class="keyword">char</span> *LinkingOutput,</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Action *, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;, InputInfo&gt; &amp;CachedResults,</span><br><span class="line">    Action::OffloadKind TargetDeviceOffloadKind) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function">ToolSelector <span class="title">TS</span><span class="params">(JA, *TC, C, isSaveTempsEnabled(),</span></span></span><br><span class="line"><span class="function"><span class="params">                  embedBitcodeInObject() &amp;&amp; !isUsingLTO())</span></span>;</span><br><span class="line">  <span class="keyword">const</span> Tool *T = TS.getTool(Inputs, CollapsedOffloadActions);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> Tool *<span class="title">getTool</span><span class="params">(ActionList &amp;Inputs,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ActionList &amp;CollapsedOffloadAction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Tool *T = combineAssembleBackendCompile(ActionChain, Inputs,</span><br><span class="line">                                                  CollapsedOffloadAction);</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">      T = combineAssembleBackend(ActionChain, Inputs, CollapsedOffloadAction);</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">      T = combineBackendCompile(ActionChain, Inputs, CollapsedOffloadAction);</span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">      Inputs = BaseAction-&gt;getInputs();</span><br><span class="line">      T = TC.SelectTool(*BaseAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    combineWithPreprocessor(T, Inputs, CollapsedOffloadAction);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到，Bind会尝试去绑定不同的Tool，BackCompile/Backend/Compile/Preprocessor等。</p><h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>有了前面的参数，Actions，ToolChain等，Job的构建就水到渠成，具体代码可以在下面找到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Driver::BuildJobs(Compilation &amp;C) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Action *, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;, InputInfo&gt; CachedResults;</span><br><span class="line">  <span class="keyword">for</span> (Action *A : C.getActions()) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *LinkingOutput = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (isa&lt;LipoJobAction&gt;(A)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (FinalOutput)</span><br><span class="line">        LinkingOutput = FinalOutput-&gt;getValue();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        LinkingOutput = getDefaultImageName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BuildJobsForAction(C, A, &amp;C.getDefaultToolChain(),</span><br><span class="line">                       <span class="comment">/*BoundArch*/</span> StringRef(),</span><br><span class="line">                       <span class="comment">/*AtTopLevel*/</span> <span class="literal">true</span>,</span><br><span class="line">                       <span class="comment">/*MultipleArchs*/</span> ArchNames.size() &gt; <span class="number">1</span>,</span><br><span class="line">                       <span class="comment">/*LinkingOutput*/</span> LinkingOutput, CachedResults,</span><br><span class="line">                       <span class="comment">/*TargetDeviceOffloadKind*/</span> Action::OFK_None);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a>Execute</h2><p>执行的逻辑其实就是在Jobs准备之后，根据相关信息执行相关的命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Driver::ExecuteCompilation(</span><br><span class="line">    Compilation &amp;C,</span><br><span class="line">    SmallVectorImpl&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">const</span> Command *&gt;&gt; &amp;FailingCommands) &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Job : C.getJobs())</span><br><span class="line">    setUpResponseFiles(C, Job);</span><br><span class="line"></span><br><span class="line">  C.ExecuteJobs(C.getJobs(), FailingCommands);</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以通过<code>-ftime-report</code> 来查看执行的过程和时间。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>虽然Driver这一层还没有涉及到真正的编译，但是作为整个编译过程的驱动，了解Driver对我们后续了解编译的全过程还是有帮助的，特别是Driver的设计，以pipline形式将各个环节的输入输出抽象，解决了参数解析和翻译，任务封装和执行等过程，以满足我们各种各样的使用需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Driver&quot;&gt;&lt;a href=&quot;#什么是Driver&quot; class=&quot;headerlink&quot; title=&quot;什么是Driver&quot;&gt;&lt;/a&gt;什么是Driver&lt;/h1&gt;&lt;p&gt;在单独编译文件时，我们经常会使用到如下的一些命令&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;clang -ccc-print-phases main.m&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里我们使用的’clang’其实不是我们通常所说的llvm的编译前端clang，而是一个命令行工具，指的就是Clang Driver，它是一个驱动，是面向用户提供接口，内部解析参数，调用编译的中的工具完成编译的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LLVM" scheme="www.shanks.pro/categories/LLVM/"/>
    
    
      <category term="clang" scheme="www.shanks.pro/tags/clang/"/>
    
      <category term="LLVM" scheme="www.shanks.pro/tags/LLVM/"/>
    
      <category term="Driver" scheme="www.shanks.pro/tags/Driver/"/>
    
  </entry>
  
  <entry>
    <title>闲话iOS探索测试实现</title>
    <link href="www.shanks.pro/2020/05/16/ios-explore-test/"/>
    <id>www.shanks.pro/2020/05/16/ios-explore-test/</id>
    <published>2020-05-16T08:17:00.000Z</published>
    <updated>2020-05-16T08:30:09.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>App中经常会有crash，为了治理crash，我们尝试了各自手段，包括提交代码前的静态检测，单元测试等，但是还是会有crash被带到线上，而一旦上线，所带来的影响和修复成本都是很大的。借鉴我们组Android同事的想法，有目的有策略地对App自动化的探索（类似于智能的Monkey），探索到的页面越多，发现问题的可能性越大。将问题收集提前报出来，就可以避免带到线上。</p><p>本章我们对探索的策略不作细说，只聊聊探索在iOS的实现的大概流程。</p><a id="more"></a><h2 id="方案确定"><a href="#方案确定" class="headerlink" title="方案确定"></a>方案确定</h2><p>涉及UI测试，第一反应想到的是iOS自带的UI测试。但是iOS的UI测试是黑盒的，只能根据<code>accessibilityIdentifier</code>等来查找元素操作，能做的有限，显然满足不了探索的要求。而如果在App内实现探索，又处理不了系统的Alert弹窗等场景，所以为了两者兼得，我采用UI测试驱动+App内部探索的方案。</p><blockquote><p>iOS的UI测试运行时会在被测试App之外生成另一个App，来驱动被测试App的行为。我们下面称我们自己的App为Host App，UI测试产生的App为Test App。</p></blockquote><p>下图大致展示整个流程，我会一个个说明。</p><p><img src="/assets/ios-explore-process.png" alt="探索流程"></p><h3 id="脚本部分"><a href="#脚本部分" class="headerlink" title="脚本部分"></a>脚本部分</h3><p>当我们需要运行探索，任务的第一执行者是我们脚本。<br>脚本的职责有以下几个：</p><h4 id="将探索仓库代码和主仓库集成"><a href="#将探索仓库代码和主仓库集成" class="headerlink" title="将探索仓库代码和主仓库集成"></a>将探索仓库代码和主仓库集成</h4><p>为了在Test App和HostApp间通信（Test App触发Host App开始和结束探索），我们需要将探索仓库中Test+Common模块和主工程的Test Target集成，将Host+Common和主Target集成。</p><p>其中Common是在Test App和Host App都会运行的公用部分，处理一些公用部分和通信部分。通信部分可以参考我的这篇<a href="https://shanks.pro/2019/12/29/ios-communicate-between-app-process/" target="_blank" rel="noopener">iOS进程间通信</a>。</p><h4 id="运行UI测试"><a href="#运行UI测试" class="headerlink" title="运行UI测试"></a>运行UI测试</h4><p>通过<code>xcodebuild</code>命令编译并运行UI测试。<br>同时监测：</p><ol><li>如果UI测试未到时间便退出，搜集本次运行信息，然后重新运行。</li><li>如果超时退出，则将之前搜集的所有运行信息整理，发出报告。</li></ol><h4 id="搜集报告"><a href="#搜集报告" class="headerlink" title="搜集报告"></a>搜集报告</h4><p>因为借助了iOS原生的UI测试，所有我们也希望借助系统现有的能力搜集报告。但是发现原生的UI测试有很多crash没有采集到，所以我通过自己在代码中捕获Exception和Signal，然后log出来，最后通过一次UI运行完之后，正则解析日志获取crash信息。</p><p>解析日志可以使用<code>xcresulttool</code>来完成，Test App进程的Host App进程的日志都能获取。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">将UI测试生成的.xcresult目录导出成可分析的log</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">export_diagnostics_logs</span><span class="params">(self, test_result_path, log_dir)</span>:</span></span><br><span class="line">        <span class="comment"># get logref id</span></span><br><span class="line">        tmp_contents_json = os.path.join(self.results_path, <span class="string">"tmp_contents.json"</span>)</span><br><span class="line">        self.util.run_command(<span class="string">'xcrun xcresulttool get --path &#123;&#125; --format json &gt; &#123;&#125;'</span>.format(test_result_path, tmp_contents_json))</span><br><span class="line">        diagnostics_id = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            json_dict = json.load(file(tmp_contents_json))</span><br><span class="line">            diagnostics_id = json_dict[<span class="string">'actions'</span>][<span class="string">'_values'</span>][<span class="number">0</span>][<span class="string">'actionResult'</span>][<span class="string">'diagnosticsRef'</span>][<span class="string">'id'</span>][<span class="string">'_value'</span>]</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line">            LOG.warning(<span class="string">"diagnostics id not found"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        self.util.run_command(<span class="string">'xcrun xcresulttool export --path &#123;&#125; --output-path &#123;&#125; --id &#123;&#125; --type directory'</span>.format(test_result_path, log_dir, diagnostics_id))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h3 id="Test-App-部分"><a href="#Test-App-部分" class="headerlink" title="Test App 部分"></a>Test App 部分</h3><p>当脚本触发了UI测试，首先会运行的是Test App。<br>我们在Test App做下面几件事：</p><ol><li>通过通信机制调用Host App的方法，通知Host App开始探索。</li><li>定时检测，如果发现Host App中出现了系统弹窗，则点掉弹窗。（这部分Host App做不到）</li><li>定时检测，如果发现Host App进入了后台，则重新唤醒Host App，因为这时可能点击导致跳出了App。</li><li>定时检测，如果Host App进入非运行状态，则结束本次UI测试，因为这时候Host App可能已经crash。<br>总的来说，Test App主要做一个触发和处理弹窗等操作，没有探索的逻辑存在。</li></ol><h3 id="Host-App"><a href="#Host-App" class="headerlink" title="Host App"></a>Host App</h3><p>前面做了那么多，其实都是为了探索的流程打通，而到了Host App，核心的职责就是探索页面。</p><ol><li>设置异常检测，当发生crash时将crash堆栈以一定的格式打印出来，分析报告时会以通用的格式解析。</li><li>获取页面所有元素，获取可操作的元素，通过策略选择选择一个元素。</li><li>通过使用UITouch实现模拟点击输入等操作，这部分可以参考<a href="https://github.com/kif-framework/KIF" target="_blank" rel="noopener">KIF</a>和<a href="https://github.com/google/EarlGrey.git" target="_blank" rel="noopener">EarlGrey</a>。</li><li>不断重复2，3，深度遍历App页面，直至探索时间截止。</li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>截止目前为止，一小时探索有80个页面，其中还有很多问题没解决，需要持续完善。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实现整个流程的过程中，踩了不少坑，同时也对UI测试，进程通信，日志解析等方面加深了理解，踩坑使我进步。</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p>Q：为什么探索仓库和主仓库分开？<br>A：这是为了和主仓库解耦，探索的所有功能都不会带上线，这样做能保持主仓库的代码的干净，而且探索仓库可以随时迭代，不受主仓库制约。</p><p>Q：怎么将探索时间这个参数传入进入App。<br>A：通过设置工程文件的<code>GCC_PREPROCESSOR_DEFINITIONS</code>或者在<code>xcodebuild</code>时传入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild <span class="built_in">test</span> xxx GCC_PREPROCESSOR_DEFINITIONS=<span class="string">"DEBUG=1 EXPLORE_TIME=1200"</span></span><br></pre></td></tr></table></figure></p><p>然后在iOS代码中，使用以下方式获取，参考<a href="http://web.archive.org/web/20160304001326/http://gcc.gnu.org/onlinedocs/cpp/Stringification.html" target="_blank" rel="noopener">Stringification</a>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define EXPLORE_MACRO_NAME(f) #f</span></span><br><span class="line"><span class="meta">#define EXPLORE_MACRO_VALUE(f) EXPLORE_MACRO_NAME(f)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * exploreTimeString = EXPLORE_MACRO_VALUE(EXPLORE_TIME);</span><br><span class="line"><span class="built_in">NSInteger</span> exploreTime = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>, exploreTimeString] integerValue];</span><br></pre></td></tr></table></figure><p>Q：Host App异常退出时，为什么不能在Test App多次运行Host App，而要通过脚本重新运行<code>xcodebuild</code>?<br>A：因为我们每次运行都需要采集Host App的运行日志，如果通过Test App重启Host App，那么等最后结束，我们只能拿到最后一次Host App运行的日志，会遗漏之前启动运行的页面/崩溃信息。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/google/EarlGrey.git" target="_blank" rel="noopener">EarlGrey</a></li><li><a href="https://github.com/kif-framework/KIF" target="_blank" rel="noopener">KIF</a></li><li><a href="http://web.archive.org/web/20160304001326/http://gcc.gnu.org/onlinedocs/cpp/Stringification.html" target="_blank" rel="noopener">Stringification</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;App中经常会有crash，为了治理crash，我们尝试了各自手段，包括提交代码前的静态检测，单元测试等，但是还是会有crash被带到线上，而一旦上线，所带来的影响和修复成本都是很大的。借鉴我们组Android同事的想法，有目的有策略地对App自动化的探索（类似于智能的Monkey），探索到的页面越多，发现问题的可能性越大。将问题收集提前报出来，就可以避免带到线上。&lt;/p&gt;
&lt;p&gt;本章我们对探索的策略不作细说，只聊聊探索在iOS的实现的大概流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.shanks.pro/categories/iOS/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="Python" scheme="www.shanks.pro/tags/Python/"/>
    
      <category term="Ruby" scheme="www.shanks.pro/tags/Ruby/"/>
    
      <category term="Explore" scheme="www.shanks.pro/tags/Explore/"/>
    
  </entry>
  
  <entry>
    <title>iOS进程间通信</title>
    <link href="www.shanks.pro/2019/12/29/ios-communicate-between-app-process/"/>
    <id>www.shanks.pro/2019/12/29/ios-communicate-between-app-process/</id>
    <published>2019-12-29T04:33:37.000Z</published>
    <updated>2020-07-14T10:00:37.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主旨"><a href="#主旨" class="headerlink" title="主旨"></a>主旨</h2><p>本章主要介绍Google在开源项目<a href="https://github.com/google/EarlGrey" target="_blank" rel="noopener">EarlGrey</a>中用到的进程间通信的方式<a href="https://github.com/google/eDistantObject" target="_blank" rel="noopener">eDistantObject</a>的实现原理。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做自动化探索测试的过程中，发现Apple提供的UI测试（黑盒），对App元素的操作有点局限，获取的信息也不能完全满足要求，所以想到是否可以通过在被测试App内部获取和操作元素（白盒），然后在另一个App（测试App）中进行全流程控制，达到兼具白盒和黑盒的效果。</p><blockquote><p>既然能在测试App内部操作，为什么还一定需要一个测试App来控制？因为在App内部没法完成所以自动化测试的公共，比如系统Alert的处理。这个不是本章重点，不赘述。</p></blockquote><p>那么问题来了，抛开Apple的UI测试，我们怎么才能在测试App中和被测试App进行通信，这里就需要有一种通信方式来在完成App间的数据沟通。下面我们介绍下eDistantObject的大致原理和实现。<br><a id="more"></a></p><h2 id="基础知识提要"><a href="#基础知识提要" class="headerlink" title="基础知识提要"></a>基础知识提要</h2><h3 id="什么是socket"><a href="#什么是socket" class="headerlink" title="什么是socket"></a>什么是socket</h3><p>引用Unix网络编程中的介绍(1.7章)</p><blockquote><p>The sockets programming interfaces described in this book are interfaces from the upper three<br>layers (the “application”) into the transport layer.<br>大致意思是，socket是一套实现应用册到传输层的接口实现。配合下面这张图会更加清晰一些。</p></blockquote><p><img src="/assets/socket-osi.png" alt="Layers in OSI model and Internet protocol suite."></p><p>至于为什么需要socket，文中也有解释，只要是两点原因。</p><ol><li>上三层协议主要处理应用层信息（FTP/HTTP）而不关注通信细节，而下四层主要处理通信细节而不关注应用层信息。</li><li>上三层作用在用户进程，而下四层通常作为OS内核的一部分提供。</li></ol><p>所以在第四和第五层之间构建这样一个沟通上下的接口就可以理解了。</p><h3 id="socket的工作方式"><a href="#socket的工作方式" class="headerlink" title="socket的工作方式"></a>socket的工作方式</h3><p>Unix网络编程中有一个实现基于TCP的例子(4.1章)，我们可以用这个来解释。</p><p><img src="/assets/socket-tcp.png" alt="Socket functions for elementary TCP client/server."></p><ol><li>server端先创建socket连接-&gt;绑定本地地址-&gt;监听端口-&gt;接受请求。</li><li>client端建立socket连接-&gt;向server端请求建立连接。</li><li>连接建立之后，client向server请求数据，server读取数据之后，给client写数据。</li><li>client收到数据之后读取出来。</li><li>所有任务结束之后断开socket连接。</li></ol><p>有关于图中每个方法的具体细节，可以直接通过man了解到.</p><h2 id="eDistantObject实现"><a href="#eDistantObject实现" class="headerlink" title="eDistantObject实现"></a>eDistantObject实现</h2><p>eDistantObject的README中提供的范例是先在Host端建立一个service，然后在client端根据Host端的端口去调用Host端的方法。这和我们上面的socket通信中的client/server模式很像。我们就先从Host建立service为切入点看下它的代码。</p><h3 id="EDOHostService"><a href="#EDOHostService" class="headerlink" title="EDOHostService"></a>EDOHostService</h3><table><thead><tr><th style="text-align:left">调用顺序</th></tr></thead><tbody><tr><td style="text-align:left">[EDOHostService serviceWithPort:rootObject:queue:]</td></tr><tr><td style="text-align:left">[EDOHostService initWithPort:rootObject:serviceName:queue:isToDevice:]</td></tr><tr><td style="text-align:left">[EDOHostService edo_createListenSocket:]</td></tr></tbody></table><p>从入口初始化一路向下，省略掉其中一些变量初始化的工作，我们把关注点放到edo_createListenSocket上，从命名上也能看出，edo_createListenSocket其实创建了一个socket连接，监听请求来的数据。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (EDOSocket *)edo_createListenSocket:(<span class="built_in">UInt16</span>)port &#123;</span><br><span class="line">  __<span class="keyword">weak</span> EDOHostService *weakSelf = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">return</span> [EDOSocket listenWithTCPPort:port</span><br><span class="line">                                queue:<span class="literal">nil</span></span><br><span class="line">                       connectedBlock:^(EDOSocket *socket, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                         EDOHostService *strongSelf = weakSelf;</span><br><span class="line">                         <span class="keyword">if</span> (!strongSelf) &#123;</span><br><span class="line">                           [socket invalidate];</span><br><span class="line">                           <span class="keyword">return</span>;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">id</span>&lt;EDOChannel&gt; clientChannel = [EDOSocketChannel channelWithSocket:socket];</span><br><span class="line">                         [strongSelf startReceivingRequestsForChannel:clientChannel];</span><br><span class="line">                       &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edo_createListenSocket的代码里，我们可以看到两部分内容，一部分是EDOSocket创建一个socket监听指定端口，另一部是在回调里处理数据。具体细节能在EDOSocket和startReceivingRequestsForChannel中找到。</p><h3 id="EDOSocket"><a href="#EDOSocket" class="headerlink" title="EDOSocket"></a>EDOSocket</h3><table><thead><tr><th style="text-align:left">调用顺序</th></tr></thead><tbody><tr><td style="text-align:left">[EDOSocket listenWithTCPPort:queue:connectedBlock:]</td></tr><tr><td style="text-align:left">[EDOListenSocket listenSocketWithSocket:connectedBlock:]</td></tr></tbody></table><p>EDOSocket的原理基本上都在上面两个方法中了，我们一个一个看。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">+ (EDOSocket *)listenWithTCPPort:(<span class="built_in">UInt16</span>)port</span><br><span class="line">                           queue:(<span class="built_in">dispatch_queue_t</span>)queue</span><br><span class="line">                  connectedBlock:(EDOSocketConnectedBlock)block &#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="comment">// 1 - socket()</span></span><br><span class="line">  dispatch_fd_t socketFD = edo_CreateSocket(&amp;socketErr);</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="comment">// 2 - bind</span></span><br><span class="line">  <span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">  memset(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">  addr.sin_port = htons(port);</span><br><span class="line">  addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);</span><br><span class="line">  <span class="keyword">if</span> (bind(socketFD, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) != <span class="number">0</span>) &#123;</span><br><span class="line">    close(socketFD);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// listen</span></span><br><span class="line">  <span class="keyword">return</span> [EDOListenSocket listenSocketWithSocket:socketFD</span><br><span class="line">                                  connectedBlock:^(EDOSocket *socket, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                                    <span class="comment">// dispatch the block to the user's queue</span></span><br><span class="line">                                    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                                      block(socket, <span class="literal">nil</span>);</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                  &#125;];</span><br><span class="line">&#125;</span><br><span class="line">+ (EDOListenSocket *)listenSocketWithSocket:(dispatch_fd_t)socketFD</span><br><span class="line">                             connectedBlock:(EDOSocketConnectedBlock)block &#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="comment">// 3 - listen</span></span><br><span class="line">  <span class="keyword">if</span> (listen(socketFD, SOMAXCONN) != <span class="number">0</span>) &#123;</span><br><span class="line">    close(socketFD);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> eventQueue =</span><br><span class="line">      dispatch_queue_create(gListenSocketQueueLabel, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">  dispatch_source_t source =</span><br><span class="line">      dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, (uintptr_t)socketFD, <span class="number">0</span>, eventQueue);</span><br><span class="line"></span><br><span class="line">  EDOListenSocket *listenSocket = [EDOListenSocket socketWithSocket:socketFD source:source];</span><br><span class="line">  __<span class="keyword">weak</span> EDOListenSocket *weakSelf = listenSocket;</span><br><span class="line">  dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">    EDOListenSocket *strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nconns = dispatch_source_get_data(source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nconns &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 4 - accept</span></span><br><span class="line">      EDOSocket *socket = [strongSelf accept:socketFD];</span><br><span class="line">      <span class="comment">// 5 - 处理数据</span></span><br><span class="line">      <span class="keyword">if</span> (socket) &#123;</span><br><span class="line">        block(socket, <span class="literal">nil</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      --nconns;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_source_set_cancel_handler(source, ^&#123;</span><br><span class="line">    <span class="comment">// Release the socket and reset it to -1.</span></span><br><span class="line">    EDOSocket *strongSelf = weakSelf;</span><br><span class="line">    [strongSelf releaseSocket];</span><br><span class="line">    close(socketFD);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  dispatch_resume(source);</span><br><span class="line">  <span class="keyword">return</span> listenSocket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面大致做了3件事</p><ol><li>调用了edo_CreateSocket创建了socket，这是封装后的方法，内部其实直接调用原始socket的socket(AF_INET, SOCK_STREAM, 0)。</li><li>紧接着调用通过bind绑定本地地址。</li><li>调用listen监听连接。</li><li>调用accept接受连接</li><li>通过回调处理数据。</li></ol><p>至此，初始化HostService的任务基本结束，从代码上看，和标准的socket初始化没什么区别。初始化完之后就剩下数据的接受和处理了。</p><blockquote><p>Unix中I/O相关的资源都使用文件描述符操作，所以这里socket创建之后返回的也是文件描述符。Everything is a file！</p></blockquote><h3 id="Host接受数据"><a href="#Host接受数据" class="headerlink" title="Host接受数据"></a>Host接受数据</h3><p>startReceivingRequestsForChannel之前，创建了一个channel来作为发送和接收数据的通道。<br>| 调用顺序 |<br>| :—– |<br>| [EDOSocketChannel channelWithSocket:] |<br>| [EDOSocketChannel initWithSocket:] |<br>| [EDOSocketChannel initWithDispatchIO:] |<br>| [EDOSocket releaseAsDispatchIO] |</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> dispatch_io_t)releaseAsDispatchIO &#123;</span><br><span class="line">  dispatch_fd_t socket = [<span class="keyword">self</span> releaseSocket];</span><br><span class="line">  <span class="comment">// 省略=</span></span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.google.edo.SocketIO"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">  dispatch_io_t channel = dispatch_io_create(DISPATCH_IO_STREAM, socket, queue, ^(<span class="keyword">int</span> error) &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，EDOSocketChannel的本质是创建了一个Dispatch I/O通道来读取client通过socket传送过来的数据。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)receiveDataWithHandler:(EDOChannelReceiveHandler)handler &#123;</span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> handlerQueue = <span class="keyword">self</span>.handlerQueue;</span><br><span class="line">  dispatch_io_t channel = <span class="keyword">self</span>.channel;</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">  dispatch_io_handler_t dataHandler = ^(<span class="keyword">bool</span> done, dispatch_data_t data, <span class="keyword">int</span> error) &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    <span class="built_in">NSMutableData</span> *receivedData =</span><br><span class="line">        [<span class="built_in">NSMutableData</span> dataWithCapacity:dispatch_data_get_size(dataReceived)];</span><br><span class="line">    dispatch_data_apply(dataReceived, ^<span class="keyword">bool</span>(dispatch_data_t region, size_t offset,</span><br><span class="line">                                            <span class="keyword">const</span> <span class="keyword">void</span> *buffer, size_t size) &#123;</span><br><span class="line">      [receivedData appendBytes:buffer length:size];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">      <span class="built_in">dispatch_async</span>(handlerQueue, ^&#123;</span><br><span class="line">        handler(<span class="keyword">self</span>, receivedData, <span class="literal">nil</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dispatch_io_handler_t frameHandler = ^(<span class="keyword">bool</span> done, dispatch_data_t data, <span class="keyword">int</span> error) &#123;</span><br><span class="line">    size_t payloadSize = EDOGetPayloadSizeFromFrameData(data);</span><br><span class="line">    <span class="comment">//省略许多</span></span><br><span class="line">    dispatch_io_read(channel, <span class="number">0</span>, payloadSize, handlerQueue, dataHandler);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dispatch_io_read(channel, <span class="number">0</span>, EDOGetPayloadHeaderSize(), handlerQueue, frameHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EDOSocketChannel内部再从Dispatch I/O中不断的读取拼接数据并将数据通过handler发送出去。<br>当通道数据发送到外面之后，就需要对收到的数据进行具体的处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startReceivingRequestsForChannel:(<span class="keyword">id</span>&lt;EDOChannel&gt;)channel &#123;</span><br><span class="line">  <span class="comment">//省略无关代码</span></span><br><span class="line">  EDOChannelReceiveHandler receiveHandler =</span><br><span class="line">      ^(<span class="keyword">id</span>&lt;EDOChannel&gt; targetChannel, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        EDOChannelReceiveHandler strongHandlerBlock = weakHandlerBlock;</span><br><span class="line">        EDOServiceRequest *request = [<span class="built_in">NSKeyedUnarchiver</span> edo_unarchiveObjectWithData:data];</span><br><span class="line">        <span class="built_in">NSString</span> *requestClassName = <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]);</span><br><span class="line">        <span class="comment">//获取匹配的handler</span></span><br><span class="line">        EDORequestHandler handler = EDOHostService.handlers[requestClassName];</span><br><span class="line">        __block EDOServiceResponse *response = <span class="literal">nil</span>;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">          __<span class="keyword">weak</span> EDOServiceRequest *weakRequest = request;</span><br><span class="line">          <span class="keyword">void</span> (^requestHandler)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            uint64_t currentTime = mach_absolute_time();</span><br><span class="line">            response = handler(weakRequest, weakSelf);</span><br><span class="line">            response.duration = EDOGetMillisecondsSinceMachTime(currentTime);</span><br><span class="line">          &#125;;</span><br><span class="line">          [strongSelf.executor handleBlock:requestHandler error:&amp;error];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSData</span> *responseData = [<span class="built_in">NSKeyedArchiver</span> edo_archivedDataWithObject:response];</span><br><span class="line">        <span class="comment">// 发送respone</span></span><br><span class="line">        [targetChannel sendData:responseData withCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">        <span class="comment">// 循环直到全部处理完</span></span><br><span class="line">        <span class="keyword">if</span> ([strongSelf edo_shouldReceiveData:channel]) &#123;</span><br><span class="line">          [targetChannel receiveDataWithHandler:strongHandlerBlock];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  receiveHandler = [receiveHandler <span class="keyword">copy</span>];</span><br><span class="line">  [channel receiveDataWithHandler:receiveHandler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要解析出request，然后根据request的类型，去除对应的handeler，执行完之后如果将response（包装成EDOObject）发送会client端。其中handler主要有以下几个:</p><ul><li>EDOClassRequest</li><li>EDOInvocationRequest</li><li>EDOMethodSignatureRequest</li><li>EDOObjectAliveRequest</li><li>EDOObjectRequest</li><li>EDOObjectReleaseRequest</li></ul><p>至此Host端（我们熟悉的socket中的Server端）以及全部结束。根据socket的流程，我们不难猜想出Client端的工作流程。</p><h3 id="EDOClientService"><a href="#EDOClientService" class="headerlink" title="EDOClientService"></a>EDOClientService</h3><table><thead><tr><th style="text-align:left">调用顺序</th></tr></thead><tbody><tr><td style="text-align:left">[EDOClientService responseObjectWithRequest:onPort:]</td></tr><tr><td style="text-align:left">[EDOClientService sendSynchronousRequest:onPort:]</td></tr><tr><td style="text-align:left">[EDOClientService sendSynchronousRequest:onPort:withExecutor]</td></tr><tr><td style="text-align:left">[EDOChannelPool channelWithPort:error:]</td></tr><tr><td style="text-align:left">[EDOChannelPool edo_createChannelWithPort:error:]</td></tr><tr><td style="text-align:left">[EDOSocket socketWithTCPPort:queue:error:]</td></tr><tr><td style="text-align:left">[EDOSocket connectWithTCPPort:queue:connectedBlock:]</td></tr></tbody></table><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)connectWithTCPPort:(<span class="built_in">UInt16</span>)port</span><br><span class="line">                     queue:(<span class="built_in">dispatch_queue_t</span>)queue</span><br><span class="line">            connectedBlock:(EDOSocketConnectedBlock)block &#123;</span><br><span class="line">  <span class="comment">// 1 - socket</span></span><br><span class="line">  dispatch_fd_t socketFD = edo_CreateSocket(&amp;socketErr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">  memset(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = htons(port);</span><br><span class="line">  addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);</span><br><span class="line">  <span class="comment">// 2 - connect</span></span><br><span class="line">  <span class="keyword">int</span> ret = connect(socketFD, (<span class="keyword">struct</span> sockaddr <span class="keyword">const</span> *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">  socketErr = errno;</span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; socketErr != EINPROGRESS) &#123;</span><br><span class="line">    edo_RunHandlerWithErrorInQueueWithBlock(socketErr, queue, block);</span><br><span class="line">    close(socketFD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显可以看到，这里也是遵循标准socket的流程，做了两件事。</p><ol><li>调用socket()创建socket。</li><li>调用connect和Host建立连接。</li></ol><p>现在两边连接已经建立，下面就到了Client调用Host的时候。</p><h3 id="EDOObject"><a href="#EDOObject" class="headerlink" title="EDOObject"></a>EDOObject</h3><p>官方README是这样说的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="comment">// The object, fetched remotely from the host is seen by the client to be the same as a local</span></span><br><span class="line">  <span class="comment">// object.</span></span><br><span class="line">  FooClass *rootObject = [EDOClientService rootObjectWithPort:portNumber];</span><br><span class="line">  [rootObject method1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的FooClass就是一个在Host中实现的普通类，之所以在Client进程中能够直接调用，是因为EDOClientService返回的是EDOObject，method1的实现并不是在Client进程，所以看起来直接调用method1能成功，是因为真正的调用会被EDOObject发送到Host端，然后将数据返回，这中间就用到OC的消息转发+socket通信。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EDOObject+Invocation</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">  <span class="comment">// TODO(haowoo): Cache the signature.</span></span><br><span class="line">  EDOServiceRequest *request = [EDOMethodSignatureRequest requestWithObject:<span class="keyword">self</span>.remoteAddress</span><br><span class="line">                                                                       port:<span class="keyword">self</span>.servicePort</span><br><span class="line">                                                                   selector:selector];</span><br><span class="line">  EDOMethodSignatureResponse *response = (EDOMethodSignatureResponse *)[EDOClientService</span><br><span class="line">      sendSynchronousRequest:request</span><br><span class="line">                      onPort:<span class="keyword">self</span>.servicePort.hostPort];</span><br><span class="line">  <span class="built_in">NSString</span> *signature = response.signature;</span><br><span class="line">  <span class="keyword">return</span> signature ? [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature.UTF8String] : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Forwards the invocation to the remote. */</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">  [<span class="keyword">self</span> edo_forwardInvocation:invocation selector:invocation.selector returnByValue:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)edo_forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">                     selector:(SEL)selector</span><br><span class="line">                returnByValue:(<span class="built_in">BOOL</span>)returnByValue &#123;</span><br><span class="line">  EDOInvocationRequest *request = [EDOInvocationRequest requestWithInvocation:invocation</span><br><span class="line">                                                                       target:<span class="keyword">self</span></span><br><span class="line">                                                                     selector:selector</span><br><span class="line">                                                                returnByValue:returnByValue</span><br><span class="line">                                                                      service:service];</span><br><span class="line">  EDOExecutor *executor = [EDOHostService serviceForCurrentExecutingQueue].executor;</span><br><span class="line">  EDOInvocationResponse *response =</span><br><span class="line">      (EDOInvocationResponse *)[EDOClientService sendSynchronousRequest:request</span><br><span class="line">                                                                 onPort:<span class="keyword">self</span>.servicePort.hostPort</span><br><span class="line">                                                           withExecutor:executor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EDOObject+Invocation文件中，覆写了methodSignatureForSelector和forwardInvocation，因为method1方法在EDOObject中肯定不存在，所以会直接走转发流程，所以消息会被封装，通过EDOChannel发送到Host进程，从Host进程拿返回数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上代码分析，可以总结出，eDistantObject使用了标准的socket流程在Host进程和Client进程建立了socket连接，然后将Client中的方法调用全部以消息转发的形式发送到Host进程，由Host进程处理完毕再返回被Client进程，达到我们表面上看起来的跨进程调用方法。<br>eDistantObject在README中也给出了一张原理图，也很好的诠释了这一过程。</p><p><img src="/assets/edistantobject-client-host.png" alt="Client-Host"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/google/eDistantObject/blob/master/docs/detail.md" target="_blank" rel="noopener">eDistantObject</a></li><li><a href="https://scoecomp.files.wordpress.com/2014/02/2003-unix-network-programming-vol-1-3rd-ed.pdf" target="_blank" rel="noopener">UNIX Network Programming</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主旨&quot;&gt;&lt;a href=&quot;#主旨&quot; class=&quot;headerlink&quot; title=&quot;主旨&quot;&gt;&lt;/a&gt;主旨&lt;/h2&gt;&lt;p&gt;本章主要介绍Google在开源项目&lt;a href=&quot;https://github.com/google/EarlGrey&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EarlGrey&lt;/a&gt;中用到的进程间通信的方式&lt;a href=&quot;https://github.com/google/eDistantObject&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;eDistantObject&lt;/a&gt;的实现原理。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在做自动化探索测试的过程中，发现Apple提供的UI测试（黑盒），对App元素的操作有点局限，获取的信息也不能完全满足要求，所以想到是否可以通过在被测试App内部获取和操作元素（白盒），然后在另一个App（测试App）中进行全流程控制，达到兼具白盒和黑盒的效果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;既然能在测试App内部操作，为什么还一定需要一个测试App来控制？因为在App内部没法完成所以自动化测试的公共，比如系统Alert的处理。这个不是本章重点，不赘述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么问题来了，抛开Apple的UI测试，我们怎么才能在测试App中和被测试App进行通信，这里就需要有一种通信方式来在完成App间的数据沟通。下面我们介绍下eDistantObject的大致原理和实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.shanks.pro/categories/iOS/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="进程间通信" scheme="www.shanks.pro/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
      <category term="eDistantObject" scheme="www.shanks.pro/tags/eDistantObject/"/>
    
      <category term="EarlGrey" scheme="www.shanks.pro/tags/EarlGrey/"/>
    
      <category term="socket" scheme="www.shanks.pro/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>iOS增量代码覆盖率</title>
    <link href="www.shanks.pro/2019/12/07/increment-code-coverage/"/>
    <id>www.shanks.pro/2019/12/07/increment-code-coverage/</id>
    <published>2019-12-07T02:05:35.000Z</published>
    <updated>2020-07-14T10:00:44.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是增量覆盖率"><a href="#什么是增量覆盖率" class="headerlink" title="什么是增量覆盖率"></a>什么是增量覆盖率</h2><p>增量覆盖率，顾名思义，指的是每次代码改动的增量部分，开发自测的覆盖程度。</p><h2 id="为什么需要增量覆盖率"><a href="#为什么需要增量覆盖率" class="headerlink" title="为什么需要增量覆盖率"></a>为什么需要增量覆盖率</h2><p>大型项目为了持续保证代码和App的质量，需要对新引入代码进行审查，而在代码被合并进去之前（比如在code review阶段），增量覆盖率无疑是衡量开发对代码的自测重复程度的一个很好的指标。</p><blockquote><p>代码覆盖率不是万能的，只能通过这个手段解决一部分明显通过自测就可以发现的问题。</p></blockquote><blockquote><p>增量代码覆盖率更偏向于开发使用，保证开发自测的充分程度。</p></blockquote><a id="more"></a><h2 id="怎么实现增量代码覆盖率"><a href="#怎么实现增量代码覆盖率" class="headerlink" title="怎么实现增量代码覆盖率"></a>怎么实现增量代码覆盖率</h2><p><img src="/assets/increment-code-coverage-plan.png" alt=""></p><p>上图展示了基本的思路，主要分3步。</p><ol><li>采集全量覆盖率</li><li>采集代码diff</li><li>根据代码diff和全量覆盖率过滤出增量覆盖率</li></ol><h3 id="采集全量覆盖率"><a href="#采集全量覆盖率" class="headerlink" title="采集全量覆盖率"></a>采集全量覆盖率</h3><p>全量覆盖率的采集，需要以下几步。</p><ul><li>配置工程，使得能在运行时插桩产生覆盖率数据。</li></ul><p>这里我们采用ruby脚本，每次需要的时候自动将配置加到工程里。需要注意的是，如果需要统计的不是主project而是依赖的子project，这个配置需要加到子的project中，因为这样子的project在编译时才能进行IR插桩。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'xcodeproj'</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">add_coverage_build_setting</span><span class="params">()</span></span></span><br><span class="line">    project = Xcodeproj::Project.open(project_path)</span><br><span class="line">    main_target = project.native_targets.first</span><br><span class="line">    main_target.build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">      <span class="keyword">if</span> config.name == <span class="string">"Debug"</span></span><br><span class="line">        config.build_settings[<span class="string">'GCC_INSTRUMENT_PROGRAM_FLOW_ARCS'</span>] = <span class="string">'YES'</span></span><br><span class="line">        config.build_settings[<span class="string">'GCC_GENERATE_TEST_COVERAGE_FILES'</span>] = <span class="string">'YES'</span></span><br><span class="line">        project.save()</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>编译时采集gcno文件。</li></ul><p>gcno包含了代码计数器和源码的映射关系，编译之后就会生成，具体目录如下。<br>不同架构下的编译产物目录根据PLATFORM_PREFERRED_ARCH不同而有所区别。<br>ps: OBJECT_FILE_DIR_normal和PLATFORM_PREFERRED_ARCH是Xcode编译时的环境变量，可以在运行xcodebuild时加上-showBuildSettings来查看所有环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJECT_FILE_DIR_normal/PLATFORM_PREFERRED_ARCH</span><br></pre></td></tr></table></figure><ul><li>运行时采集gcda文件。<br>gcda 记录了每段代码具体的执行次数，运行时产生，具体生成的目录需要自己指定。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line">    <span class="built_in">NSString</span> *coverageDir = [<span class="keyword">self</span> coverageDir];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"coverage path:%@"</span>, coverageDir);</span><br><span class="line">    setenv(<span class="string">"GCOV_PREFIX"</span>, [coverageDir cStringUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span>], <span class="number">1</span>);</span><br><span class="line">    setenv(<span class="string">"GCOV_PREFIX_STRIP"</span>, <span class="string">"11"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>在应用进入后台或者其他时机，可以选择主动调用__gcov_flush();来刷新本地的覆盖率数据。<br>在实际操作中，我们对模拟器和真机采取不同策略，模拟器因为沙盒目录其实就在mac本地，所以我们把gcda移动到我们的工作目录，编译后面生成覆盖率数据。真机我们选择将gcda上传到文件服务器，需要的时候从服务器拉下来辅助我们产生覆盖率数据。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    __gcov_flush();</span><br><span class="line"><span class="meta">#if TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">    [<span class="keyword">self</span> flushToNative];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    [<span class="keyword">self</span> flushToRemote];</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><blockquote><p>当写入gcda内容时，如果发生写入的内容和文件中已有的内容有冲突，我们需要先删除本地原来的文件。将Apple源码中GCDAProfiling.c拷贝入自己的工程，对其中写入gcda代码作修改即可。</p></blockquote><ul><li>运行完触发全量覆盖率的生生成。</li></ul><p>全量覆盖率的产生需要借助<a href="https://manpages.debian.org/unstable/lcov/lcov.1.en.html" target="_blank" rel="noopener">lcov</a>和<a href="https://manpages.debian.org/unstable/lcov/genhtml.1.en.html" target="_blank" rel="noopener">genhtml</a>。lcov帮我们生成中间文件info，包含了所有的代码信息和覆盖率信息，genhtml帮我们将info文件转换成可视化html。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成info文件</span></span><br><span class="line">lcov --capture --directory &#123;gcda目录&#125; --base-directory &#123;源代码目录&#125; --output-file &#123;指定生成的info文件地址&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成html</span></span><br><span class="line">genhtml &#123;生成的info文件地址&#125; --output-directory &#123;指定生成的报告目录&#125;</span><br></pre></td></tr></table></figure><h3 id="获取代码diff信息"><a href="#获取代码diff信息" class="headerlink" title="获取代码diff信息"></a>获取代码diff信息</h3><p>Diff的获取相对简单，我们平常用git就可以拿到，如果用脚本，可以参考以下代码。<br>因为我们最终目的是增量覆盖率，所以我们在这里的核心其实就是拿到git记录中，行前面有+的行信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> git</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">get_diff</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""获取diff详情"""</span></span><br><span class="line">        repository = git.Repo(self.repo_path)</span><br><span class="line">        diff = repository.git.diff(self.dst_commit, self.src_commit).split(<span class="string">"\n"</span>)</span><br><span class="line">        ret = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        file_name = <span class="string">""</span></span><br><span class="line">        diff_lines = []</span><br><span class="line">        current_line = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> diff:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">'diff --git'</span>):</span><br><span class="line">                <span class="comment"># 进入新的block</span></span><br><span class="line">                <span class="keyword">if</span> file_name != <span class="string">""</span>:</span><br><span class="line">                    ret[file_name] = diff_lines</span><br><span class="line">                tmp_result = re.findall(<span class="string">'b/(\S+)$'</span>, line)</span><br><span class="line">                <span class="keyword">if</span> tmp_result:</span><br><span class="line">                    file_name = tmp_result[<span class="number">0</span>]</span><br><span class="line">                    diff_lines = []</span><br><span class="line">                    current_line = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> re.match(<span class="string">'@@ -\d+,\d+ \+(\d+),\d+ @@'</span>, line):</span><br><span class="line">                match = re.match(<span class="string">'@@ -\d+,\d+ \+(\d+),\d+ @@'</span>, line)</span><br><span class="line">                current_line = int(match.group(<span class="number">1</span>)) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> line.startswith(<span class="string">"-"</span>) <span class="keyword">and</span> <span class="keyword">not</span> line.startswith(<span class="string">'---'</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> line.startswith(<span class="string">"+"</span>) <span class="keyword">and</span> <span class="keyword">not</span> line.startswith(<span class="string">'+++'</span>):</span><br><span class="line">                current_line += <span class="number">1</span></span><br><span class="line">                diff_lines.append(current_line)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_line += <span class="number">1</span></span><br><span class="line">        ret[file_name] = diff_lines</span><br><span class="line">        change_list = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> ret.iteritems():</span><br><span class="line">            change_list.append((key, value))</span><br><span class="line">        <span class="keyword">return</span> change_list</span><br></pre></td></tr></table></figure><h3 id="获取增量覆盖率"><a href="#获取增量覆盖率" class="headerlink" title="获取增量覆盖率"></a>获取增量覆盖率</h3><p>现在我们拿到了全量覆盖率，同时也拿到了增量的代码行信息，怎么才能从中过滤出增量的代码覆盖率？<br>如果从最终的html入手去过滤，肯定是费时费力而且不稳定的，那么往前一步，我们在生成html之前有生成一个.info的文件，通过<a href="https://manpages.debian.org/unstable/lcov/geninfo.1.en.html" target="_blank" rel="noopener">geninfo</a>文档我们可以看出，这个文件包含了所有代码的信息以及代码运行的信息，这正是我们需要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">TN:&lt;test name&gt;</span><br><span class="line"></span><br><span class="line">For each source file referenced in the .da file, there is a section containing filename and coverage data:</span><br><span class="line"></span><br><span class="line">SF:&lt;absolute path to the source file&gt;</span><br><span class="line"></span><br><span class="line">Following is a list of line numbers for each function name found in the source file:</span><br><span class="line"></span><br><span class="line">FN:&lt;line number of function start&gt;,&lt;function name&gt;</span><br><span class="line"></span><br><span class="line">Next, there is a list of execution counts for each instrumented function:</span><br><span class="line"></span><br><span class="line">FNDA:&lt;execution count&gt;,&lt;function name&gt;</span><br><span class="line"></span><br><span class="line">This list is followed by two lines containing the number of functions found and hit:</span><br><span class="line"></span><br><span class="line">FNF:&lt;number of functions found&gt; FNH:&lt;number of function hit&gt;</span><br><span class="line"></span><br><span class="line">Branch coverage information is stored which one line per branch:</span><br><span class="line"></span><br><span class="line">BRDA:&lt;line number&gt;,&lt;block number&gt;,&lt;branch number&gt;,&lt;taken&gt;</span><br><span class="line"></span><br><span class="line">Block number and branch number are gcc internal IDs for the branch. Taken is either &apos;-&apos; if the basic block containing the branch was never executed or a number indicating how often that branch was taken.</span><br><span class="line"></span><br><span class="line">Branch coverage summaries are stored in two lines:</span><br><span class="line"></span><br><span class="line">BRF:&lt;number of branches found&gt; BRH:&lt;number of branches hit&gt;</span><br><span class="line"></span><br><span class="line">Then there is a list of execution counts for each instrumented line (i.e. a line which resulted in executable code):</span><br><span class="line"></span><br><span class="line">DA:&lt;line number&gt;,&lt;execution count&gt;[,&lt;checksum&gt;]</span><br><span class="line"></span><br><span class="line">Note that there may be an optional checksum present for each instrumented line. The current geninfo implementation uses an MD5 hash as checksumming algorithm.</span><br><span class="line"></span><br><span class="line">At the end of a section, there is a summary about how many lines were found and how many were actually instrumented:</span><br><span class="line"></span><br><span class="line">LH:&lt;number of lines with a non-zero execution count&gt; LF:&lt;number of instrumented lines&gt;</span><br><span class="line"></span><br><span class="line">Each sections ends with:</span><br><span class="line"></span><br><span class="line">end_of_record</span><br></pre></td></tr></table></figure><p>所以我们只要解析出info文件，然后通过增量代码的行信息，从info文件中过滤出所有增量代码及其相关覆盖信息，就可以达到我们的效果。</p><ul><li>解析info文件</li></ul><p>这里参考我写的脚本<a href="https://github.com/shanksGuo/InfoParser" target="_blank" rel="noopener">Script</a></p><ul><li>过滤出增量代码重新生成info。</li></ul><p>这里在上一步的脚本中有相关代码，主要是标记info解析出的func是否是diff的方法，最终通过record的to_diff_info重新生成info文件。</p><ul><li>运用genhtml重新生成html。</li></ul><p>这一步还是和全量覆盖率中一致。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在以上方案中，当多次运行代码，如果代码产生的覆盖率信息有冲突，__gcov_flush();的刷新策略不会将其覆盖，所以如果前后两次代码如果有冲突，很可能我们需要删掉App重新运行，这将是很费劲的。<br>所以我们将llvm的GCDAProfiling.c源码拿来，对覆盖刷新的部分做修改，如果有冲突则删除上一份保留最新的。<br>因为覆盖率插桩是编译器做的，实际运行时也会用到GCDAProfiling，所以我们这样做其实替换了插桩代码用到的GCDAProfiling。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里大致叙述了做增量覆盖率时的一些思路，想把整个流程做完善并且易于使用，还是需要结合自己工程和开发流程做一些工作，才能让这个工具易用方便。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://tech.meituan.com/2018/12/27/ios-increment-coverage.html" target="_blank" rel="noopener">美团</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是增量覆盖率&quot;&gt;&lt;a href=&quot;#什么是增量覆盖率&quot; class=&quot;headerlink&quot; title=&quot;什么是增量覆盖率&quot;&gt;&lt;/a&gt;什么是增量覆盖率&lt;/h2&gt;&lt;p&gt;增量覆盖率，顾名思义，指的是每次代码改动的增量部分，开发自测的覆盖程度。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要增量覆盖率&quot;&gt;&lt;a href=&quot;#为什么需要增量覆盖率&quot; class=&quot;headerlink&quot; title=&quot;为什么需要增量覆盖率&quot;&gt;&lt;/a&gt;为什么需要增量覆盖率&lt;/h2&gt;&lt;p&gt;大型项目为了持续保证代码和App的质量，需要对新引入代码进行审查，而在代码被合并进去之前（比如在code review阶段），增量覆盖率无疑是衡量开发对代码的自测重复程度的一个很好的指标。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码覆盖率不是万能的，只能通过这个手段解决一部分明显通过自测就可以发现的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;增量代码覆盖率更偏向于开发使用，保证开发自测的充分程度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.shanks.pro/categories/iOS/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="增量" scheme="www.shanks.pro/tags/%E5%A2%9E%E9%87%8F/"/>
    
      <category term="覆盖率" scheme="www.shanks.pro/tags/%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
      <category term=".info" scheme="www.shanks.pro/tags/info/"/>
    
      <category term="lcov" scheme="www.shanks.pro/tags/lcov/"/>
    
  </entry>
  
  <entry>
    <title>浅析.framework的生成</title>
    <link href="www.shanks.pro/2019/04/09/framework-parse/"/>
    <id>www.shanks.pro/2019/04/09/framework-parse/</id>
    <published>2019-04-09T02:22:56.000Z</published>
    <updated>2019-04-09T05:27:27.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近项目需要将在独立仓库生成的.framework集成进来，同时又希望是static framwork，原因是动态framework在启动时链接会消耗启动时间，这是我们不想看到的。而我们自己独立仓库使用的cocoapods管理，使用cocoapods-packager打出来的framework没有将Resources单独分开，导致带资源bundle的framework被静态链接时会被Testflight打回（正常编译没问题）。<br>所以我们要做的就是将cocoapods-packager生成的static framework中资源剥离开单独在Build Phases中设置。当然，从生成framwork，到剥离Resources，再到集成项目设置都是在我们CI中自动化实现。</p><a id="more"></a><h2 id="framework是什么"><a href="#framework是什么" class="headerlink" title="framework是什么"></a>framework是什么</h2><p>要把Resources从framework中拆分出来，要先弄清楚framework是什么。从苹果官方文档可以找到答案。</p><blockquote><p>A framework is a hierarchical directory that encapsulates shared resources, such as a dynamic shared library, nib files, image files, localized strings, header files, and reference documentation in a single package. Multiple applications can use all of these resources simultaneously. The system loads them into memory as needed and shares the one copy of the resource among all applications whenever possible.</p></blockquote><p>简单来说，一个framework就是一个多层目录，包含代码(library)，头文件(header files)和资源(nib, image, localized strings)。<br>从苹果的文档中也可以看到，framework的层级大致如下。其中MyFramework和Resources并非实体目录，而知识一个symbol link，连接到Versions/Current下面的MyFramework和Resources。Current也是一个symbol link，链接到A。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MyFramework.framework/</span><br><span class="line">    MyFramework  -&gt; Versions/Current/MyFramework</span><br><span class="line">    Resources    -&gt; Versions/Current/Resources</span><br><span class="line">    Versions/</span><br><span class="line">        A/</span><br><span class="line">            MyFramework</span><br><span class="line">            Resources/</span><br><span class="line">                English.lproj/</span><br><span class="line">                    InfoPlist.strings</span><br><span class="line">                Info.plist</span><br><span class="line">        Current  -&gt; A</span><br></pre></td></tr></table></figure><p>上述内容可以通过命令验证，我们新建了一个framework，通过ls -l可以看到结果。</p><p><img src="/assets/performance-ls-1.jpg" alt="alt text"></p><p><img src="/assets/performance-ls-2.jpg" alt="alt text"></p><p>至于为什么要搞这么复杂，需要link到Current再link到A，可以自行参考文末文档。</p><h2 id="cocoapods-packager怎么做的"><a href="#cocoapods-packager怎么做的" class="headerlink" title="cocoapods-packager怎么做的"></a>cocoapods-packager怎么做的</h2><p>知道了framework只是一个目录，那把Resources直接从framework中移动出来应该就能解决问题。但总有些不放心，所以我们再看下cocoapods-packager是怎么生成framwork的。</p><p>cocoapods-packager生成framework大致分以下几个步骤。</p><ol><li>编译代码，这是为了检验代码正确性。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span></span></span><br><span class="line">    defines = <span class="string">"GCC_PREPROCESSOR_DEFINITIONS='$(inherited) PodsDummy_Pods_<span class="subst">#&#123;@spec.name&#125;</span>=PodsDummy_PodPackage_<span class="subst">#&#123;@spec.name&#125;</span>'"</span></span><br><span class="line">    defines &lt;&lt; <span class="string">' '</span> &lt;&lt; @spec.consumer(@platform).compiler_flags.join(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> @platform.name == <span class="symbol">:ios</span></span><br><span class="line">    options = ios_build_options</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    xcodebuild(defines, options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> @mangle</span><br><span class="line">    <span class="keyword">return</span> build_with_mangling(options)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    defines</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建framwork目录，以及Headers, Resources等子目录</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_framework</span></span></span><br><span class="line">    @fwk = Framework::Tree.new(@spec.name, @platform.name.to_s, @embedded)</span><br><span class="line">    @fwk.make</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make</span></span></span><br><span class="line">    make_root</span><br><span class="line">    make_framework</span><br><span class="line">    make_headers</span><br><span class="line">    make_resources</span><br><span class="line">    make_current_version</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_current_version</span></span></span><br><span class="line">    current_version_path = @versions_path + Pathname.new(<span class="string">'../Current'</span>)</span><br><span class="line">    <span class="string">`ln -sf A <span class="subst">#&#123;current_version_path&#125;</span>`</span></span><br><span class="line">    <span class="string">`ln -sf Versions/Current/Headers <span class="subst">#&#123;@fwk_path&#125;</span>/`</span></span><br><span class="line">    <span class="string">`ln -sf Versions/Current/Resources <span class="subst">#&#123;@fwk_path&#125;</span>/`</span></span><br><span class="line">    <span class="string">`ln -sf Versions/Current/<span class="subst">#&#123;@name&#125;</span> <span class="subst">#&#123;@fwk_path&#125;</span>/`</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>值得一提的是，创建完目录有个link的过程，是通过ls -sf src target来创建symbol link，这点和我们之前说到的一致。</p><ol start="3"><li>生成静态library</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_static_library_for_ios</span><span class="params">(output)</span></span></span><br><span class="line">    static_libs = static_libs_in_sandbox(<span class="string">'build'</span>) + static_libs_in_sandbox(<span class="string">'build-sim'</span>) + vendored_libraries</span><br><span class="line">    libs = ios_architectures.map <span class="keyword">do</span> <span class="params">|arch|</span></span><br><span class="line">      library = <span class="string">"<span class="subst">#&#123;@static_sandbox_root&#125;</span>/build/package-<span class="subst">#&#123;arch&#125;</span>.a"</span></span><br><span class="line">      <span class="string">`libtool -arch_only <span class="subst">#&#123;arch&#125;</span> -static -o <span class="subst">#&#123;library&#125;</span> <span class="subst">#&#123;static_libs.join(<span class="string">' '</span>)&#125;</span>`</span></span><br><span class="line">      library</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="string">`lipo -create -output <span class="subst">#&#123;output&#125;</span> <span class="subst">#&#123;libs.join(<span class="string">' '</span>)&#125;</span>`</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>先单独对每种架构生成.a，再将所有合并生成一个universal library。</p><ol start="4"><li>拷贝头文件,license和资源</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_static_framework</span></span></span><br><span class="line">  <span class="comment"># ....</span></span><br><span class="line"></span><br><span class="line">  copy_headers</span><br><span class="line">  copy_license</span><br><span class="line">  copy_resources</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里做的就是将之前编译产物里的头文件，license和资源拷贝到framework目录下，代码就不赘述。</p><h2 id="资源分离方案"><a href="#资源分离方案" class="headerlink" title="资源分离方案"></a>资源分离方案</h2><p>通过苹果官方文档和对cocoapods-packager源码的分析，我们可以确定framework其实就是一种特殊的目录结构，所以想要达到我们的目的，将资源从中分离出来，要做的其实就是文件和目录的操作。</p><ol><li>删除framework根目录中Resources的symbol link</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm xxx.framework/Resources</span><br></pre></td></tr></table></figure><ol start="2"><li>移动Versions/A/Resources里面的内容，并且删除Versions/A/Resources目录</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(resource_dir):</span><br><span class="line">    file_path = os.path.join(resource_dir, filename)</span><br><span class="line">    LOG.info(<span class="string">"move file: &#123;&#125; to target dir: &#123;&#125;"</span>.format(file_path, target_path))</span><br><span class="line">    shutil.move(file_path, target_path)</span><br><span class="line">shutil.rmtree(resource_dir)</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183-SW1" target="_blank" rel="noopener">What are Frameworks</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;最近项目需要将在独立仓库生成的.framework集成进来，同时又希望是static framwork，原因是动态framework在启动时链接会消耗启动时间，这是我们不想看到的。而我们自己独立仓库使用的cocoapods管理，使用cocoapods-packager打出来的framework没有将Resources单独分开，导致带资源bundle的framework被静态链接时会被Testflight打回（正常编译没问题）。&lt;br&gt;所以我们要做的就是将cocoapods-packager生成的static framework中资源剥离开单独在Build Phases中设置。当然，从生成framwork，到剥离Resources，再到集成项目设置都是在我们CI中自动化实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="framework" scheme="www.shanks.pro/categories/framework/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="framework" scheme="www.shanks.pro/tags/framework/"/>
    
      <category term="ruby" scheme="www.shanks.pro/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>记一次ReactNative的多线程crash</title>
    <link href="www.shanks.pro/2019/02/18/react-native-imageloader-crash/"/>
    <id>www.shanks.pro/2019/02/18/react-native-imageloader-crash/</id>
    <published>2019-02-18T13:53:03.000Z</published>
    <updated>2019-03-07T09:03:25.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用ReactNative v0.51版本时，发现线上有个崩溃一直没有解决，为了完成App治理crash的目标，所以花了点时间研究如何解决这个问题。<br><a id="more"></a></p><h2 id="Crash介绍"><a href="#Crash介绍" class="headerlink" title="Crash介绍"></a>Crash介绍</h2><p><img src="/assets/rn-crash-reccomend.png" alt="alt text"></p><p><img src="/assets/rn-crash-distribute.png" alt="alt text"></p><p>可以看到如下信息</p><ol><li>崩溃位置</li></ol><blockquote><p>[RCTHTTPRequestHandler sendRequest:withDelegate:]</p></blockquote><ol start="2"><li>崩溃线程</li></ol><blockquote><p>#27 Thread - 子线程</p></blockquote><ol start="3"><li>崩溃原因</li></ol><blockquote><p>NSGenericException</p></blockquote><ol start="4"><li>崩溃描述</li></ol><blockquote><p>Task created in a session that has been invalidated</p></blockquote><ol start="5"><li>崩溃分布</li></ol><blockquote><p>没有很明显的特征</p></blockquote><h2 id="直接崩溃原因"><a href="#直接崩溃原因" class="headerlink" title="直接崩溃原因"></a>直接崩溃原因</h2><p>根据崩溃原因NSGenericException，可以知道这是一个OC异常。我们先尝试找到直接导致崩溃的原因是什么，再找到真正触发的条件。</p><p>根据描述”Task created in a session that has been invalidated”，大概能看出一个失效的session对象尝试去创建task导致异常，而sendRequest:withDelegate:方法中创建task的地方只有一个</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSession</span> *_session;</span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)sendRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                         withDelegate:(<span class="keyword">id</span>&lt;RCTURLRequestDelegate&gt;)delegate &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="built_in">NSURLSessionDataTask</span> *task = [_session dataTaskWithRequest:request];</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而session为什么会invalidate的原因也很简单，因为[NSURLSession invalidateAndCancel].</p><p><img src="/assets/rn-crash-invalidate.png" alt="alt text"></p><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><p>知道直接崩溃原因，我们就要找到触发崩溃的原因。根据上面的证据，我们推测RCTHTTPRequestHandler肯定调用了invalidateAndCancel，事实也正是这样。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTHTTPRequestHandler.mm</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">  [_session invalidateAndCancel];</span><br><span class="line">  _session = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果_session被置为nil，则不会发生问题，所以肯定是[_session invalidateAndCancel]和_session = nil执行之间被打断了，结合之前的堆栈信息，卡顿发生在子线程，基本可以肯定这是一个多线程的问题，导致[RCTHTTPRequestHandler invalidate]的方法执行没有保证原子性。</p><p>那我们就要找出sendRequest:withDelegate:和invalidate各自的调用链。</p><h3 id="sendRequest"><a href="#sendRequest" class="headerlink" title="sendRequest"></a>sendRequest</h3><p><img src="/assets/rn-crash-imageloader.png" alt="alt text"></p><p>根据崩溃堆栈，我们可以看到sendRequest是在RCTImageLoader中发起的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_URLRequestQueue = dispatch_queue_create(<span class="string">"com.facebook.react.ImageLoaderURLRequestQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dequeueTasks</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(_URLRequestQueue, ^&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        [task start];</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以sendRequest是在名为”com.facebook.react.ImageLoaderURLRequestQueue”的串行队列中执行.</p><h3 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h3><p>通过源码，可以找到invalidate的调用路径</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-&gt;RCTBridge.dealloc</span></span><br><span class="line"><span class="comment">-&gt;RCTBridge.invalidate</span></span><br><span class="line"><span class="comment">-&gt;RCTCxxBridge.invalidate</span></span><br><span class="line"><span class="comment">-&gt;[moduleData.instance invalidate]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">  <span class="comment">//...省略</span></span><br><span class="line">  <span class="keyword">if</span> ([moduleData.instance respondsToSelector:<span class="keyword">@selector</span>(invalidate)]) &#123;</span><br><span class="line">    dispatch_group_enter(moduleInvalidation);</span><br><span class="line">    [<span class="keyword">self</span> dispatchBlock:^&#123;</span><br><span class="line">      [(<span class="keyword">id</span>&lt;RCTInvalidating&gt;)moduleData.instance invalidate];</span><br><span class="line">      dispatch_group_leave(moduleInvalidation);</span><br><span class="line">    &#125; queue:moduleData.methodQueue];</span><br><span class="line">  &#125;</span><br><span class="line">  [moduleData invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://shanks.pro/2019/01/10/react-native-communication/" target="_blank" rel="noopener">RN原理</a>， 可以知道moduleData是在RN初始化的时候注册的模块信息，RCTHTTPRequestHandler也会生成其中一个moduleData。 那我们看下moduleData.methodQueue是什么，因为这就是invalidate执行的队列。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUpMethodQueue &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  _queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"com.facebook.react.%@Queue"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">    _methodQueue = dispatch_queue_create(_queueName.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"> [(<span class="keyword">id</span>)_instance setValue:_methodQueue forKey:<span class="string">@"methodQueue"</span>];</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，每个module都会又一个对应的串行methodQueue，并且名称的规则是”com.facebook.react.%@Queue”, 所以RCTHTTPRequestHandler对应的队列就是”com.facebook.react.HTTPRequestHandlerQueue”</p><p>也即，invalidate是在串行队列””com.facebook.react.HTTPRequestHandlerQueue””中执行。</p><h3 id="还不够！"><a href="#还不够！" class="headerlink" title="还不够！"></a>还不够！</h3><p>就算知道了sendRequest和invalidate方法在不同队列的线程中执行，还不能百分百确定一定会发生多线程问题，除非RCTCxxBridge.invalidate中触发的moduleData实例和RCTImageLoader触发的sendRequest中RCTHTTPRequestHandler实例是同一个对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTNetworkTask中获取RCTHTTPRequestHandler的方法</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;RCTURLRequestHandler&gt;)handlerForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">  _handlers = [[<span class="keyword">self</span>.bridge modulesConformingToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">RCTURLRequestHandler</span>)] <span class="title">sortedArrayUsingComparator</span>:^<span class="title">NSComparisonResult</span>(<span class="title">id</span>&lt;<span class="title">RCTURLRequestHandler</span>&gt; <span class="title">a</span>, <span class="title">id</span>&lt;<span class="title">RCTURLRequestHandler</span>&gt; <span class="title">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> priorityA = [a respondsToSelector:<span class="keyword">@selector</span>(handlerPriority)] ? [a handlerPriority] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> priorityB = [b respondsToSelector:<span class="keyword">@selector</span>(handlerPriority)] ? [b handlerPriority] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (priorityA &gt; priorityB) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">NSOrderedAscending</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priorityA &lt; priorityB) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">NSOrderedDescending</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">NSOrderedSame</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTBridge.m</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)modulesConformingToProtocol:(Protocol *)protocol</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSMutableArray</span> *modules = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">  <span class="keyword">for</span> (Class moduleClass <span class="keyword">in</span> [<span class="keyword">self</span>.moduleClasses <span class="keyword">copy</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([moduleClass conformsToProtocol:protocol]) &#123;</span><br><span class="line">      <span class="keyword">id</span> module = [<span class="keyword">self</span> moduleForClass:moduleClass];</span><br><span class="line">      <span class="keyword">if</span> (module) &#123;</span><br><span class="line">        [modules addObject:module];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [modules <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，RCTNetworkTask执行时用到的handler，是从RCTBridge之前注册好的module中去找到符合<rcturlrequesthandler>协议的对象。最终结果找到也是RCTHTTPRequestHandler对象。</rcturlrequesthandler></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCTHTTPRequestHandler</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTURLRequestHandler</span>, <span class="title">RCTInvalidating</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>至此可以发现，RCTHTTPRequestHandler其实生成的实例对象，在一个RCTBridge周期内只有一个。同一个RCTHTTPRequestHandler对象的invalidate和sendRequest的执行在不同队列的不同子线程。虽然两个队列都是串行，但是两个子线程之间互相之间没有约束，一个执行时可能会被另一个打断，从而导致执行了[_session invalidateAndCancel]之后执行[_session dataTaskWithRequest:request]导致crash。</p><h2 id="怎么复现"><a href="#怎么复现" class="headerlink" title="怎么复现"></a>怎么复现</h2><p>我复现的方式是，在RCTHTTPRequestHandler的invalidate方法中插入sleep，加大RCTHTTPRequestHandler中invalidate方法被打断的概率，同时在外面模拟RCTBridge的invalidate。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTHTTPRequestHandler</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">  [_session invalidateAndCancel];</span><br><span class="line">  sleep(<span class="number">3</span>);</span><br><span class="line">  _session = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样很容易能复现这个问题。</p><h2 id="怎么修复"><a href="#怎么修复" class="headerlink" title="怎么修复"></a>怎么修复</h2><p>既然两个线程在不同的队列执行，那最简单的修复方式就是把他们的执行放到同一个队列中去，这样两块代码再执行的时候顺序不会被中途打断。<br>之前我们也看到，每个moduleData都有自己的methodQueue，那比较好的方式还是在RCTHTTPRequestHandler内部用他自己的methodQueue。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synthesize</span> methodQueue = _methodQueue;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidate&#123;</span><br><span class="line">  <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>-&gt;_methodQueue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span>-&gt;_session invalidateAndCancel];</span><br><span class="line">    <span class="keyword">self</span>-&gt;_session = <span class="literal">nil</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)sendRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                         withDelegate:(<span class="keyword">id</span>&lt;RCTURLRequestDelegate&gt;)delegate &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>-&gt;_methodQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span>-&gt;session dataTaskWithRequest:request];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给ReactNative提PR"><a href="#给ReactNative提PR" class="headerlink" title="给ReactNative提PR"></a>给ReactNative提PR</h2><p>既然这里存在问题，并且改动还算合理，我就尝试把这个修改提交给ReactNative，看人家会不会采纳。最终PR还是被合并了，Bingo!<br><a href="https://github.com/facebook/react-native/pull/22746" target="_blank" rel="noopener">https://github.com/facebook/react-native/pull/22746</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个crash我们可以看到，多线程的问题比较隐蔽，所以我们平时在写代码和做code review时，要特别注意线程安全，对共享变量的使用要比较小心。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用ReactNative v0.51版本时，发现线上有个崩溃一直没有解决，为了完成App治理crash的目标，所以花了点时间研究如何解决这个问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="Crash" scheme="www.shanks.pro/categories/Crash/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="ReactNative" scheme="www.shanks.pro/tags/ReactNative/"/>
    
      <category term="MultiThread" scheme="www.shanks.pro/tags/MultiThread/"/>
    
      <category term="Crash" scheme="www.shanks.pro/tags/Crash/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative源码分析-通信机制(基于iOS)</title>
    <link href="www.shanks.pro/2019/01/10/react-native-communication/"/>
    <id>www.shanks.pro/2019/01/10/react-native-communication/</id>
    <published>2019-01-10T05:40:45.000Z</published>
    <updated>2019-03-07T09:29:42.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备-JavaScriptCore"><a href="#准备-JavaScriptCore" class="headerlink" title="准备-JavaScriptCore"></a>准备-JavaScriptCore</h2><p>在开篇，我们先简单准备下JavaScriptCore的知识。这是整个Native和JS沟通的最底层的桥梁。<br><a id="more"></a></p><p><strong><em>Classes</em></strong></p><ul><li><p>JSContext <br><br>JS的执行上下文<br><br><img src="/assets/jscontext.jpg" alt=""></p></li><li><p>JSManagedValue<br><br>主要用于防止Native导出对象时持有JSValue导致循环引用</p></li><li><p>JSValue<br><br>JavaScript值的引用，转换JavaScript和Native之间的基本数据<br><br><img src="/assets/jsvalue.jpg" alt=""></p></li><li><p>JSVirtualMachine<br><br>提供JS执行环境<br><br><img src="/assets/jsvm.jpg" alt=""></p></li><li><p>JSExport<br><br>导出Native到JavaScript</p></li></ul><p><strong><em>相对应的底层C实现</em></strong></p><ul><li>JSBase</li><li>JSContextRef</li><li>JSObjectRef</li><li>JSStringRef</li><li>JSStringRefCF</li><li>JSValueRef</li></ul><h2 id="ReactNative通信原理"><a href="#ReactNative通信原理" class="headerlink" title="ReactNative通信原理"></a>ReactNative通信原理</h2><p>从ReactNative的demo开始，入口我们只看到两个东西RCTRootView和RCTBridge。RCTRootView负责展示，RCTBridge则和ReactNative的通信有关。</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(__unused <span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">  _bridge = [[RCTBridge alloc] initWithDelegate:<span class="keyword">self</span></span><br><span class="line">                                  launchOptions:launchOptions];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:_bridge</span><br><span class="line">                                                   moduleName:<span class="string">@"RNTesterApp"</span></span><br><span class="line">                                            initialProperties:initProps];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">  <span class="built_in">UIViewController</span> *rootViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">  rootViewController.view = rootView;</span><br><span class="line">  <span class="keyword">self</span>.window.rootViewController = rootViewController;</span><br><span class="line">  [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RCTCxxBridge初始化"><a href="#RCTCxxBridge初始化" class="headerlink" title="RCTCxxBridge初始化"></a>RCTCxxBridge初始化</h3><p>跟着调用链会看到，bridge的初始化会走到RCTCxxBridge中的start<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTCxxBrige.mm</span></span><br><span class="line"><span class="comment">//只贴了关键代码</span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">  dispatch_group_t prepareBridge = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化native modules</span></span><br><span class="line">  (<span class="keyword">void</span>)[<span class="keyword">self</span> _initializeModules:RCTGetModuleClasses() withDispatchGroup:prepareBridge lazilyDiscovered:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化底层Instance</span></span><br><span class="line">  dispatch_group_enter(prepareBridge);</span><br><span class="line">  [<span class="keyword">self</span> ensureOnJavaScriptThread:^&#123;</span><br><span class="line">    [weakSelf _initializeBridge:executorFactory];</span><br><span class="line">    dispatch_group_leave(prepareBridge);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载js代码</span></span><br><span class="line">  dispatch_group_enter(prepareBridge);</span><br><span class="line">  __block <span class="built_in">NSData</span> *sourceCode;</span><br><span class="line">  [<span class="keyword">self</span> loadSource:^(<span class="built_in">NSError</span> *error, RCTSource *source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      [weakSelf handleError:error];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceCode = source.data;</span><br><span class="line">    dispatch_group_leave(prepareBridge);</span><br><span class="line">  &#125; onProgress:^(RCTLoadingProgress *progressData) &#123;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行js代码</span></span><br><span class="line">  dispatch_group_notify(prepareBridge, dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, <span class="number">0</span>), ^&#123;</span><br><span class="line">    RCTCxxBridge *strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (sourceCode &amp;&amp; strongSelf.loading) &#123;</span><br><span class="line">      [strongSelf executeSourceCode:sourceCode sync:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>start方法里做了这么几件事：</p><ul><li>初始化native modules</li><li>初始化Instance-&gt;底层负责通信</li><li>加载本地js</li></ul><p>要想了解native modules的初始化，我们要先看下之前的准备工作。</p><h3 id="native-modules导出模块"><a href="#native-modules导出模块" class="headerlink" title="native modules导出模块"></a>native modules导出模块</h3><p>通过RCT_EXPORT_MODULE将本地的模块导出供JS使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTBridgeModule.h</span></span><br><span class="line"><span class="meta">#define RCT_EXPORT_MODULE(js_name) \</span></span><br><span class="line">RCT_EXTERN <span class="keyword">void</span> RCTRegisterModule(Class); \</span><br><span class="line">+ (<span class="built_in">NSString</span> *)moduleName &#123; <span class="keyword">return</span> @<span class="meta">#js_name; &#125; \</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123; RCTRegisterModule(<span class="keyword">self</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RCTRegisterModule(Class moduleClass) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    RCTModuleClasses = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    RCTModuleClassesSyncQueue = dispatch_queue_create(<span class="string">"com.facebook.react.ModuleClassesSyncQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  &#125;);</span><br><span class="line">  dispatch_barrier_async(RCTModuleClassesSyncQueue, ^&#123;</span><br><span class="line">    [RCTModuleClasses addObject:moduleClass];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终导出的模块会被保存到RCTModuleClasses，使用时通过RCTGetModuleClasses()获取。RCTGetModuleClasses()就是在上面初始化native modules时用到的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTBridge.m</span></span><br><span class="line"><span class="built_in">NSArray</span>&lt;Class&gt; *RCTGetModuleClasses(<span class="keyword">void</span>) &#123;</span><br><span class="line">  __block <span class="built_in">NSArray</span>&lt;Class&gt; *result;</span><br><span class="line">  <span class="built_in">dispatch_sync</span>(RCTModuleClassesSyncQueue, ^&#123;</span><br><span class="line">    result = [RCTModuleClasses <span class="keyword">copy</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="native-modules导出方法"><a href="#native-modules导出方法" class="headerlink" title="native modules导出方法"></a>native modules导出方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTBridgeModule.h</span></span><br><span class="line"><span class="meta">#define RCT_EXPORT_METHOD(method) \</span></span><br><span class="line">  RCT_REMAP_METHOD(, method)</span><br><span class="line"></span><br><span class="line"><span class="meta">#define RCT_REMAP_METHOD(js_name, method) \</span></span><br><span class="line">  _RCT_EXTERN_REMAP_METHOD(js_name, method, <span class="literal">NO</span>) \</span><br><span class="line">  - (<span class="keyword">void</span>)method RCT_DYNAMIC;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define _RCT_EXTERN_REMAP_METHOD(js_name, method, is_blocking_synchronous_method) \</span></span><br><span class="line">  + (<span class="keyword">const</span> RCTMethodInfo *)RCT_CONCAT(__rct_export__, RCT_CONCAT(js_name, RCT_CONCAT(__LINE__, __COUNTER__))) &#123; \</span><br><span class="line">    <span class="keyword">static</span> RCTMethodInfo config = &#123;<span class="meta">#js_name, #method, is_blocking_synchronous_method&#125;; \</span></span><br><span class="line">    <span class="keyword">return</span> &amp;config; \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>将方法导出，最终生成以下方法提供给外部调用。通过遍历这个类中所有以<br>“__rct_export__“开头的方法就可以获取属于这个类的所有导出方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTBridgeModule.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RCTMethodInfo &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> jsName;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> objcName;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">BOOL</span> isSync;</span><br><span class="line">&#125; RCTMethodInfo;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">const</span> RCTMethodInfo *)__rct_export__+js_name+__LINE__+__COUNTER__ &#123;</span><br><span class="line">    <span class="keyword">static</span> RCTMethodInfo config = &#123;</span><br><span class="line">        js_name,</span><br><span class="line">        method,</span><br><span class="line">        is_blocking_synchronous_method</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成RCTModuleData"><a href="#生成RCTModuleData" class="headerlink" title="生成RCTModuleData"></a>生成RCTModuleData</h3><p>初始化native modules的工作，其实就是根据之前导出的类和方法，生成对应的RCTModuleData对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;RCTModuleData *&gt; *)_registerModulesForClasses:(<span class="built_in">NSArray</span>&lt;Class&gt; *)moduleClasses</span><br><span class="line">                                        lazilyDiscovered:(<span class="built_in">BOOL</span>)lazilyDiscovered &#123;</span><br><span class="line">  <span class="built_in">NSArray</span> *moduleClassesCopy = [moduleClasses <span class="keyword">copy</span>];</span><br><span class="line">  <span class="built_in">NSMutableArray</span>&lt;RCTModuleData *&gt; *moduleDataByID = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:moduleClassesCopy.count];</span><br><span class="line">  <span class="keyword">for</span> (Class moduleClass <span class="keyword">in</span> moduleClassesCopy) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *moduleName = RCTBridgeModuleNameForClass(moduleClass);</span><br><span class="line">    RCTModuleData *moduleData = _moduleDataByName[moduleName];</span><br><span class="line">    <span class="keyword">if</span> (moduleData) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass bridge:<span class="keyword">self</span>];</span><br><span class="line">    _moduleDataByName[moduleName] = moduleData;</span><br><span class="line">    [_moduleClassesByID addObject:moduleClass];</span><br><span class="line">    [moduleDataByID addObject:moduleData];</span><br><span class="line">  &#125;</span><br><span class="line">  [_moduleDataByID addObjectsFromArray:moduleDataByID];</span><br><span class="line">  <span class="keyword">return</span> moduleDataByID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们完成了本地模块和方法的导出，并且生成了一组RCTModuleData对象来表示他们。</p><h3 id="初始化Instance"><a href="#初始化Instance" class="headerlink" title="初始化Instance"></a>初始化Instance</h3><p>我们继续看Instance的初始化。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化底层Instance</span></span><br><span class="line">  dispatch_group_enter(prepareBridge);</span><br><span class="line">  [<span class="keyword">self</span> ensureOnJavaScriptThread:^&#123;</span><br><span class="line">    [weakSelf _initializeBridge:executorFactory];</span><br><span class="line">    dispatch_group_leave(prepareBridge);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">  - (<span class="keyword">void</span>)_initializeBridge:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory &#123;</span><br><span class="line">  <span class="keyword">if</span> (_reactInstance) &#123;</span><br><span class="line">    [<span class="keyword">self</span> _initializeBridgeLocked:executorFactory];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">- (<span class="keyword">void</span>)_initializeBridgeLocked:(std::shared_ptr&lt;JSExecutorFactory&gt;)executorFactory &#123;</span><br><span class="line">  _reactInstance-&gt;initializeBridge(</span><br><span class="line">                                   std::make_unique&lt;RCTInstanceCallback&gt;(<span class="keyword">self</span>),</span><br><span class="line">                                   executorFactory,</span><br><span class="line">                                   _jsMessageThread,</span><br><span class="line">                                   [<span class="keyword">self</span> _buildModuleRegistryUnlocked]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Instance.cpp</span></span><br><span class="line"><span class="keyword">void</span> Instance::initializeBridge(</span><br><span class="line">    std::unique_ptr&lt;InstanceCallback&gt; callback,</span><br><span class="line">    std::shared_ptr&lt;JSExecutorFactory&gt; jsef,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue,</span><br><span class="line">    std::shared_ptr&lt;ModuleRegistry&gt; moduleRegistry) &#123;</span><br><span class="line">  callback_ = std::move(callback);</span><br><span class="line">  moduleRegistry_ = std::move(moduleRegistry);</span><br><span class="line"></span><br><span class="line">  jsQueue-&gt;runOnQueueSync([<span class="keyword">this</span>, &amp;jsef, jsQueue]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</span><br><span class="line">        jsef.get(), moduleRegistry_, jsQueue, callback_);</span><br><span class="line"></span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(m_syncMutex);</span><br><span class="line">    m_syncReady = <span class="literal">true</span>;</span><br><span class="line">    m_syncCV.notify_all();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化Instance需要一下几个元素：</p><ul><li><p>InstanceCallback类型的回调，用于底层执行结束后往上层回调。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> InstanceCallback &#123;</span><br><span class="line">  virtual ~InstanceCallback() &#123;&#125;</span><br><span class="line">  virtual <span class="keyword">void</span> onBatchComplete() &#123;&#125;</span><br><span class="line">  virtual <span class="keyword">void</span> incrementPendingJSCalls() &#123;&#125;</span><br><span class="line">  virtual <span class="keyword">void</span> decrementPendingJSCalls() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>JSExecutorFactory类型的对象，用于生成JSExecutor用于真正执行JS。生产返回使用的是JSCExecutorFactory，返回JSIExecutor用于执行JS，调试使用的是RCTObjcExecutorFactory,返回RCTObjcExecutor通过websocket链接chrome执行JS。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> JSExecutorFactory &#123;</span><br><span class="line">public:</span><br><span class="line">  virtual std::unique_ptr&lt;JSExecutor&gt; createJSExecutor(</span><br><span class="line">    std::shared_ptr&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue) = <span class="number">0</span>;</span><br><span class="line">  virtual ~JSExecutorFactory() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产</span></span><br><span class="line"><span class="keyword">class</span> JSCExecutorFactory : public JSExecutorFactory &#123;</span><br><span class="line">public:</span><br><span class="line">  std::unique_ptr&lt;JSExecutor&gt; createJSExecutor(</span><br><span class="line">    std::shared_ptr&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue) override &#123;</span><br><span class="line">    <span class="keyword">return</span> folly::make_unique&lt;JSIExecutor&gt;(</span><br><span class="line">      facebook::jsc::makeJSCRuntime(),</span><br><span class="line">      delegate,</span><br><span class="line">      [](<span class="keyword">const</span> std::string &amp;message, <span class="keyword">unsigned</span> <span class="keyword">int</span> logLevel) &#123;</span><br><span class="line">        _RCTLogJavaScriptInternal(</span><br><span class="line">          static_cast&lt;RCTLogLevel&gt;(logLevel),</span><br><span class="line">          [<span class="built_in">NSString</span> stringWithUTF8String:message.c_str()]);</span><br><span class="line">      &#125;,</span><br><span class="line">      JSIExecutor::defaultTimeoutInvoker,</span><br><span class="line">      nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调试</span></span><br><span class="line">std::unique_ptr&lt;JSExecutor&gt; RCTObjcExecutorFactory::createJSExecutor(</span><br><span class="line">    std::shared_ptr&lt;ExecutorDelegate&gt; delegate,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue) &#123;</span><br><span class="line">  <span class="keyword">return</span> std::unique_ptr&lt;JSExecutor&gt;(</span><br><span class="line">    new RCTObjcExecutor(m_jse, m_errorBlock, jsQueue, delegate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MessageQueueThread类型对象用于提供队列执行。这里是由RCTMessageThread来实现，内部用的是CFRunLoop来实现。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueueThread.h</span></span><br><span class="line"><span class="keyword">class</span> MessageQueueThread &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual ~MessageQueueThread() &#123;&#125;</span><br><span class="line">  virtual <span class="keyword">void</span> runOnQueue(std::function&lt;<span class="keyword">void</span>()&gt;&amp;&amp;) = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// runOnQueueSync and quitSynchronous are dangerous.  They should only be</span></span><br><span class="line">  <span class="comment">// used for initialization and cleanup.</span></span><br><span class="line">  virtual <span class="keyword">void</span> runOnQueueSync(std::function&lt;<span class="keyword">void</span>()&gt;&amp;&amp;) = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Once quitSynchronous() returns, no further work should run on the queue.</span></span><br><span class="line">  virtual <span class="keyword">void</span> quitSynchronous() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">_jsMessageThread = std::make_shared&lt;RCTMessageThread&gt;([<span class="built_in">NSRunLoop</span> currentRunLoop], ^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      [weakSelf handleError:error];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>ModuleRegistry，这个包含native module信息的对象，它的来源就是我们上面看到的RCTModuleData。可以看到最终透传参数生成了RCTNativeModule</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RCTCxxBridge.mm</span></span><br><span class="line">- (std::shared_ptr&lt;ModuleRegistry&gt;)_buildModuleRegistryUnlocked &#123;</span><br><span class="line">  auto registry = std::make_shared&lt;ModuleRegistry&gt;(</span><br><span class="line">         createNativeModules(_moduleDataByID, <span class="keyword">self</span>, _reactInstance),</span><br><span class="line">         moduleNotFoundCallback);</span><br><span class="line">  <span class="keyword">return</span> registry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCTCxxUtils.mm</span></span><br><span class="line">std::vector&lt;std::unique_ptr&lt;NativeModule&gt;&gt; createNativeModules(<span class="built_in">NSArray</span>&lt;RCTModuleData *&gt; *modules, RCTBridge *bridge, <span class="keyword">const</span> std::shared_ptr&lt;Instance&gt; &amp;instance)</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;NativeModule&gt;&gt; nativeModules;</span><br><span class="line">  <span class="keyword">for</span> (RCTModuleData *moduleData <span class="keyword">in</span> modules) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([moduleData.moduleClass isSubclassOfClass:[RCTCxxModule <span class="keyword">class</span>]]) &#123;</span><br><span class="line">      <span class="comment">//跨平台，Android用</span></span><br><span class="line">      nativeModules.emplace_back(std::make_unique&lt;CxxNativeModule&gt;(</span><br><span class="line">        instance,</span><br><span class="line">        [moduleData.name UTF8String],</span><br><span class="line">        [moduleData] &#123; <span class="keyword">return</span> [(RCTCxxModule *)(moduleData.instance) createModule]; &#125;,</span><br><span class="line">        std::make_shared&lt;DispatchMessageQueueThread&gt;(moduleData)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nativeModules.emplace_back(std::make_unique&lt;RCTNativeModule&gt;(bridge, moduleData));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nativeModules;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有必要提一下，这上面的moduleData.instance，其实就是生成这个模块对应实例<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithModuleClass:(Class)moduleClass</span><br><span class="line">                             bridge:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithModuleClass:moduleClass</span><br><span class="line">                    moduleProvider:^<span class="keyword">id</span>&lt;RCTBridgeModule&gt;&#123; <span class="keyword">return</span> [moduleClass new]; &#125;</span><br><span class="line">                            bridge:bridge];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时也会准备好它所对应的bridge和method queue<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//RCTModuleData.mm</span></span><br><span class="line"> - (<span class="keyword">void</span>)setBridgeForInstance</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ([_instance respondsToSelector:<span class="keyword">@selector</span>(bridge)] &amp;&amp; _instance.bridge != _bridge) &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">      [(<span class="keyword">id</span>)_instance setValue:_bridge forKey:<span class="string">@"bridge"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUpMethodQueue</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_instance &amp;&amp; !_methodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> implementsMethodQueue = [_instance respondsToSelector:<span class="keyword">@selector</span>(methodQueue)];</span><br><span class="line">    <span class="keyword">if</span> (implementsMethodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">      _methodQueue = _instance.methodQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_methodQueue &amp;&amp; _bridge.valid) &#123;</span><br><span class="line">      _queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"com.facebook.react.%@Queue"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">      _methodQueue = dispatch_queue_create(_queueName.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// assign it to the module</span></span><br><span class="line">      <span class="keyword">if</span> (implementsMethodQueue) &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">          [(<span class="keyword">id</span>)_instance setValue:_methodQueue forKey:<span class="string">@"methodQueue"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RCT_PROFILE_END_EVENT(RCTProfileTagAlways, <span class="string">@""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时我们看到Instance::initializeBridge中生成了NativeToJsBridge，到这里Instance的初始化就结束了，下面进入NativeToJsBridge。</p><h3 id="NativeToJsBridge"><a href="#NativeToJsBridge" class="headerlink" title="NativeToJsBridge"></a>NativeToJsBridge</h3><p>NativeToJsBridge作用主要是桥接Native和JS，它包含几个关键属性</p><ul><li><p>&lt;JsToNativeBridge&gt; m_delegate<br>JsToNativeBridge类型的引用，主要用于JS call Native</p></li><li><p>&lt;JSExecutor&gt; m_executor<br> JSExecutor类型引用，主要用于执行Native call JS，这里实际使用是的是JSIExecutor(生产)/RCTObjcExecutor(调试)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;JSExecutorFactory&gt; executorFactory;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.executorClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">RCTCxxBridgeDelegate</span>)]) </span>&#123;</span><br><span class="line">      <span class="keyword">id</span>&lt;RCTCxxBridgeDelegate&gt; cxxDelegate = (<span class="keyword">id</span>&lt;RCTCxxBridgeDelegate&gt;) <span class="keyword">self</span>.delegate;</span><br><span class="line">      executorFactory = [cxxDelegate jsExecutorFactoryForBridge:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!executorFactory) &#123;</span><br><span class="line">      <span class="comment">//生产使用JSCExecutorFactory会生成JSIExecuror</span></span><br><span class="line">      executorFactory = std::make_shared&lt;JSCExecutorFactory&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//调试用RCTObjcExecutorFactory生成RCTObjcExecutor</span></span><br><span class="line">    <span class="keyword">id</span>&lt;RCTJavaScriptExecutor&gt; objcExecutor = [<span class="keyword">self</span> moduleForClass:<span class="keyword">self</span>.executorClass];</span><br><span class="line">    executorFactory.reset(new RCTObjcExecutorFactory(objcExecutor, ^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        [weakSelf handleError:error];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>&lt;MessageQueueThread&gt; m_executorMessageQueueThread<br>MessageQueueThread类型引用，由上层传递，用于队列管理</p></li></ul><h3 id="JSIExecutor"><a href="#JSIExecutor" class="headerlink" title="JSIExecutor"></a>JSIExecutor</h3><p>JSIExecutor主要用来Native call JS，包含几个主要属性：</p><ul><li>&lt;jsi::Runtime&gt; runtime_ <br>Runtime类型指针，代表JS的运行时。这是一个抽象类，其实际上是由JSCRuntime来实现的，JSCRuntime中的功能其实就是通过JavaScriptCode来完成（使用的C函数接口）。JSCRuntime上线了&lt;jsi::Runtime&gt;接口，提供了创建JS上下文的功能，同时可以执行JS。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSCRuntime::evaluateJavaScript(</span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">const</span> jsi::Buffer&gt; buffer,</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; sourceURL) &#123;</span><br><span class="line">  std::string tmp(</span><br><span class="line">      reinterpret_cast&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(buffer-&gt;data()), buffer-&gt;size());</span><br><span class="line">  JSStringRef sourceRef = JSStringCreateWithUTF8CString(tmp.c_str());</span><br><span class="line">  JSStringRef sourceURLRef = nullptr;</span><br><span class="line">  <span class="keyword">if</span> (!sourceURL.empty()) &#123;</span><br><span class="line">    sourceURLRef = JSStringCreateWithUTF8CString(sourceURL.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  JSValueRef exc = nullptr;</span><br><span class="line">  JSValueRef res =</span><br><span class="line">      JSEvaluateScript(ctx_, sourceRef, nullptr, sourceURLRef, <span class="number">0</span>, &amp;exc);</span><br><span class="line">  JSStringRelease(sourceRef);</span><br><span class="line">  <span class="keyword">if</span> (sourceURLRef) &#123;</span><br><span class="line">    JSStringRelease(sourceURLRef);</span><br><span class="line">  &#125;</span><br><span class="line">  checkException(res, exc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>&lt;ExecutorDelegate&gt; delegate_<br>ExecutorDelegate类型的指针，这里的ExecutorDelegate是抽象类，实际是由JsToNative来实现的。也即JSIExecutor引用了JsToNative。</p></li><li><p>&lt;JSINativeModules&gt; nativeModules_<br>JSINativeModules由上层传入的ModuleRegistry构造而成，同时会将ModuleRegistry中包含的本地模块配置信息通过”__fbGenNativeModule”保存到JS端。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSINativeModules.cpp</span></span><br><span class="line">folly::Optional&lt;Object&gt; JSINativeModules::createModule(</span><br><span class="line">    Runtime&amp; rt,</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!m_genNativeModuleJS) &#123;</span><br><span class="line">    m_genNativeModuleJS =</span><br><span class="line">        rt.global().getPropertyAsFunction(rt, <span class="string">"__fbGenNativeModule"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  auto result = m_moduleRegistry-&gt;getConfig(name);</span><br><span class="line">  </span><br><span class="line">  Value moduleInfo = m_genNativeModuleJS-&gt;call(</span><br><span class="line">      rt,</span><br><span class="line">      valueFromDynamic(rt, result-&gt;config),</span><br><span class="line">      static_cast&lt;<span class="keyword">double</span>&gt;(result-&gt;index));</span><br><span class="line">  CHECK(!moduleInfo.isNull()) &lt;&lt; <span class="string">"Module returned from genNativeModule is null"</span>;</span><br><span class="line">  <span class="keyword">return</span> module;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NativeModules.js</span></span><br><span class="line">global.__fbGenNativeModule = genModule;</span><br></pre></td></tr></table></figure><p>genModule会根据ModuleRegistry生成的module和method信息生成JS端的方法，结构类似：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: moduleName,</span><br><span class="line">  module: &#123;</span><br><span class="line">    methodName: func</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JSIExecutor执行js方法的实现值得说下。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JSIExecutor::callFunction(</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; moduleId,</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; methodId,</span><br><span class="line">    <span class="keyword">const</span> folly::dynamic&amp; arguments) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!callFunctionReturnFlushedQueue_) &#123;</span><br><span class="line">    bindBridge();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto errorProducer = [=] &#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">"moduleID: "</span> &lt;&lt; moduleId &lt;&lt; <span class="string">" methodID: "</span> &lt;&lt; methodId</span><br><span class="line">       &lt;&lt; <span class="string">" arguments: "</span> &lt;&lt; folly::toJson(arguments);</span><br><span class="line">    <span class="keyword">return</span> ss.str();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Value ret = Value::undefined();</span><br><span class="line">  try &#123;</span><br><span class="line">    scopedTimeoutInvoker_(</span><br><span class="line">        [&amp;] &#123;</span><br><span class="line">          ret = callFunctionReturnFlushedQueue_-&gt;call(</span><br><span class="line">              *runtime_,</span><br><span class="line">              moduleId,</span><br><span class="line">              methodId,</span><br><span class="line">              valueFromDynamic(*runtime_, arguments));</span><br><span class="line">        &#125;,</span><br><span class="line">        std::move(errorProducer));</span><br><span class="line">  &#125; catch (...) &#123;</span><br><span class="line">    std::throw_with_nested(</span><br><span class="line">        std::runtime_error(<span class="string">"Error calling "</span> + moduleId + <span class="string">"."</span> + methodId));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callNativeModules(ret, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中callFunctionReturnFlushedQueue_来自和JS端的属性绑定<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSIExecutor.cpp</span></span><br><span class="line">Object batchedBridge = batchedBridgeValue.asObject(*runtime_);</span><br><span class="line">callFunctionReturnFlushedQueue_ = batchedBridge.getPropertyAsFunction(</span><br><span class="line">        *runtime_, <span class="string">"callFunctionReturnFlushedQueue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//MessageQueue.js</span></span><br><span class="line">callFunctionReturnFlushedQueue(module: string, method: string, args: any[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.__guard(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.__callFunction(module, method, args);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到callFunctionReturnFlushedQueue_会调用JS端的callFunctionReturnFlushedQueue方法，最终调用在JS端注册好的JS模块和方法。<br>而getPropertyAsFunction则是通过runtime来实现。（runtime是JS和Native沟通的桥梁）</p><h3 id="JsToNativeBridge"><a href="#JsToNativeBridge" class="headerlink" title="JsToNativeBridge"></a>JsToNativeBridge</h3><p>JsToNativeBridge的实现就简单很多，直接通过ModuleRegistry注册好的native信息，调用对应模块的对应方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> callNativeModules(</span><br><span class="line">      JSExecutor&amp; executor, folly::dynamic&amp;&amp; calls, <span class="keyword">bool</span> isEndOfBatch) override &#123;</span><br><span class="line">        </span><br><span class="line">    m_batchHadNativeModuleCalls = m_batchHadNativeModuleCalls || !calls.empty();</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; call : parseMethodCalls(std::move(calls))) &#123;</span><br><span class="line">      m_registry-&gt;callNativeMethod(call.moduleId, call.methodId, std::move(call.arguments), call.callId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEndOfBatch) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m_batchHadNativeModuleCalls) &#123;</span><br><span class="line">        m_callback-&gt;onBatchComplete();</span><br><span class="line">        m_batchHadNativeModuleCalls = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      m_callback-&gt;decrementPendingJSCalls();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中m_registry就是上层传入的ModuleRegistry对象</p><p>那JS Call Native的整套流程是怎样的呢？</p><p> - JS调用MessageQueue.enqueueNativeCall<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enqueueNativeCall(</span><br><span class="line">    moduleID: number,</span><br><span class="line">    methodID: number,</span><br><span class="line">    params: any[],</span><br><span class="line">    onFail: ?Function,</span><br><span class="line">    onSucc: ?Function,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>._queue[MODULE_IDS].push(moduleID);</span><br><span class="line">    <span class="keyword">this</span>._queue[METHOD_IDS].push(methodID);</span><br><span class="line">    <span class="keyword">this</span>._queue[PARAMS].push(params);</span><br><span class="line">    <span class="keyword">const</span> now = Date.now();</span><br><span class="line">    <span class="comment">//MIN_TIME_BETWEEN_FLUSHES_MS = 5</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      global.nativeFlushQueueImmediate &amp;&amp;</span><br><span class="line">      now - <span class="keyword">this</span>._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> queue = <span class="keyword">this</span>._queue;</span><br><span class="line">      <span class="keyword">this</span>._queue = [[], [], [], <span class="keyword">this</span>._callID];</span><br><span class="line">      <span class="keyword">this</span>._lastFlush = now;</span><br><span class="line">      global.nativeFlushQueueImmediate(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到5ms刷新一次</p><ul><li>nativeFlushQueueImmediate对应本地的方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSIExecutor.cpp</span></span><br><span class="line">runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      <span class="string">"nativeFlushQueueImmediate"</span>,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, <span class="string">"nativeFlushQueueImmediate"</span>),</span><br><span class="line">          <span class="number">1</span>,</span><br><span class="line">          [<span class="keyword">this</span>](</span><br><span class="line">              jsi::Runtime&amp;,</span><br><span class="line">              <span class="keyword">const</span> jsi::Value&amp;,</span><br><span class="line">              <span class="keyword">const</span> jsi::Value* args,</span><br><span class="line">              size_t count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">1</span>) &#123;</span><br><span class="line">              throw std::invalid_argument(</span><br><span class="line">                  <span class="string">"nativeFlushQueueImmediate arg count must be 1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            callNativeModules(args[<span class="number">0</span>], <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> Value::undefined();</span><br><span class="line">          &#125;));</span><br></pre></td></tr></table></figure></li></ul><p>可以看到runtime_获取到全局上下文(即JS端的global)，将nativeFlushQueueImmediate属性关联到本地callNativeModules方法。<br>这里值得一提的是，runtime_-&gt;global().setProperty用在很多将JS属性和native方法对象等绑定。</p><ul><li>callNativeModules<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSIExecutor.cpp</span></span><br><span class="line"><span class="keyword">void</span> JSIExecutor::callNativeModules(<span class="keyword">const</span> Value&amp; queue, <span class="keyword">bool</span> isEndOfBatch) &#123;</span><br><span class="line">  delegate_-&gt;callNativeModules(</span><br><span class="line">      *<span class="keyword">this</span>, dynamicFromValue(*runtime_, queue), isEndOfBatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>delegate_就是我们上面提到的&lt;ExecutorDelegate&gt;类型指针，实际就是JsToNativeBridge，最终也就走到了我们上面说的callNativeModules。</p><p>到这里，我们已经具备了native call js和js call native的能力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/assets/uml.jpg" alt="UML图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备-JavaScriptCore&quot;&gt;&lt;a href=&quot;#准备-JavaScriptCore&quot; class=&quot;headerlink&quot; title=&quot;准备-JavaScriptCore&quot;&gt;&lt;/a&gt;准备-JavaScriptCore&lt;/h2&gt;&lt;p&gt;在开篇，我们先简单准备下JavaScriptCore的知识。这是整个Native和JS沟通的最底层的桥梁。&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="www.shanks.pro/categories/ReactNative/"/>
    
    
      <category term="iOS" scheme="www.shanks.pro/tags/iOS/"/>
    
      <category term="ReactNative" scheme="www.shanks.pro/tags/ReactNative/"/>
    
      <category term="源码" scheme="www.shanks.pro/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="uml" scheme="www.shanks.pro/tags/uml/"/>
    
  </entry>
  
</feed>
